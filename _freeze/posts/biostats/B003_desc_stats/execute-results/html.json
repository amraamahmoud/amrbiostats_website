{
  "hash": "ba5ba5374a760f6c839fc0051e8dbad1",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Measures of Central Tendency\"\nimage: \"/images/biostats.png\"\ndate: \"2024-10-08\"\nformat: \n  html: \n    fig-align: center\n    page-layout: article\n    toc: true\n    toc-depth: 5\n    toc-expand: true\n    lightbox: false\ncrossref: \n  custom: \n    - kind: float\n      reference-prefix: \"Example M.10.\"\n      key: tabset\n      space-before-numbering: false\neditor_options: \n  chunk_output_type: console\n---\n\n::: {.cell}\n\n:::\n\n\n\n## Background\n\n-   Collected data possess many observations that we are not interested in each one individually.\n\n-   Instead, we are interested in summarizing the data in a concise and informative way.\n\n-   Descriptive measures are single numbers that summarize the data.\n\n-   They are used to describe the `center` and `spread` of the data.\n\n-   They can be calculated from the data of a sample or a population.\n\n-   Descriptive measures calculated from the sample are referred to as sample `statistics`, while those calculated from the population are referred to as population `parameters`.\n\n## Measures of central tendency\n\n-   Measures of central tendency are used to describe the center of the data (i.e., the average or typical value).\n\n-   They are also referred to as measures of location.\n\n-   The most common measures of central tendency are the `mean`, `median`, and `mode`.\n\n### Arithmetic Mean\n\n-   It is calculated by summing all observations and dividing by the total number of observations.\n\n-   Let $X$ is a random variable:\n\n    -   The mean of a finite population of size $N$ is denoted by $\\mu$, which reads as `mu`, while the mean of a sample of size $n$ is denoted by $\\bar{x}$, which reads as `x-bar`.\n\n    -   The population and sample means can be calculated as follows:\n\n        | Population mean | Sample mean |\n        |:--:|:--:|\n        | $\\mu = \\displaystyle \\frac{x_1 + x_2 + \\ldots + x_N}{N} = \\displaystyle     \\frac{\\displaystyle \\sum_{i=1}^{N} x_i}{N}$ | $\\bar{x} = \\displaystyle \\frac{x_1 + x_2 + \\ldots + x_n}{n} = \\displaystyle \\frac{\\displaystyle \\sum_{i=1}^{n} x_i}{n}$ |\n\n-   Example: consider the variable `mpg` in the `mtcars` dataset that we discussed in earlier chapters:\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    mtcars$mpg\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n     [1] 21.0 21.0 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 17.8 16.4 17.3 15.2 10.4\n    [16] 10.4 14.7 32.4 30.4 33.9 21.5 15.5 15.2 13.3 19.2 27.3 26.0 30.4 15.8 19.7\n    [31] 15.0 21.4\n    ```\n    \n    \n    :::\n    :::\n\n\n\n    -   The number of observations can be calculated using the `length()` function:\n\n\n\n        ::: {.cell}\n        \n        ```{.r .cell-code}\n        length(mtcars$mpg)\n        ```\n        \n        ::: {.cell-output .cell-output-stdout}\n        \n        ```\n        [1] 32\n        ```\n        \n        \n        :::\n        :::\n\n\n\n    -   The sum of all values can be calculated using the `sum()` function:\n\n\n\n        ::: {.cell}\n        \n        ```{.r .cell-code}\n        sum(mtcars$mpg)\n        ```\n        \n        ::: {.cell-output .cell-output-stdout}\n        \n        ```\n        [1] 642.9\n        ```\n        \n        \n        :::\n        :::\n\n\n\n    -   $\\bar{x} = \\displaystyle \\frac{21 + 21 + 22.8 + \\ldots + 21.4}{32} = \\frac{642.9}{32} \\approx 20.09$\n\n    -   The mean can be calculated directly using the built-in R function `mean()`:\n\n\n\n        ::: {.cell}\n        \n        ```{.r .cell-code}\n        mean(mtcars$mpg)\n        ```\n        \n        ::: {.cell-output .cell-output-stdout}\n        \n        ```\n        [1] 20.09062\n        ```\n        \n        \n        :::\n        :::\n\n\n\n        ::: {.callout-note style=\"color: #0466c8;\"}\n        -   If the variable contains missing values, the `na.rm` argument should be set to `TRUE` to exclude them before calculating the mean, otherwise, the result will be `NA`.\n\n        -   For example, consider the following variable with some missing values $(1,\\ 2,\\ 3,\\ \\text{NA},\\ 5)$:\n\n            -   Using the `mean()` function without the `na.rm` argument will return `NA`:\n\n\n\n            ::: {.cell}\n            \n            ```{.r .cell-code}\n            x <- c(1, 2, 3, NA, 5)\n            mean(x)\n            ```\n            \n            ::: {.cell-output .cell-output-stdout}\n            \n            ```\n            [1] NA\n            ```\n            \n            \n            :::\n            :::\n\n\n\n            -   This error can be avoided by setting the `na.rm` argument to `TRUE`:\n\n\n\n            ::: {.cell}\n            \n            ```{.r .cell-code}\n            mean(x, na.rm = TRUE)\n            ```\n            \n            ::: {.cell-output .cell-output-stdout}\n            \n            ```\n            [1] 2.75\n            ```\n            \n            \n            :::\n            :::\n\n\n        :::\n\n-   The mean can be calculated if the values are given along with their frequencies as weighted mean:\n\n    -   Let $x_1, x_2, \\ldots, x_k$ be the values of a variable with frequencies $f_1, f_2, \\ldots, f_k$, then the weighted mean is calculated as:\n\n    $$\n    \\bar{x} = \\displaystyle \\frac{f_1x_1 + f_2x_2 + \\ldots + f_kx_k}{f_1 + f_2 + \\ldots + f_k} = \\displaystyle \\frac{\\displaystyle \\sum_{i=1}^{k} f_ix_i}{\\displaystyle \\sum_{i=1}^{k} f_i}\n    $$\n\n    -   The **weight** of each observation $\\displaystyle w_i =   \\frac{f_i}{\\displaystyle \\sum_{i=1}^{k} f_i}$, therefore, the above equation can also be written as $\\bar{x} = \\displaystyle \\sum_{i=1}^{k} w_ix_i$\n\n    -   Example: consider the following variable with values $(1.3,\\ 2.1,\\ 3.5,\\ 4.1,\\ 5.2)$ and frequencies $(2,\\ 3,\\ 1,\\ 4,\\ 2)$:\n\n\n\n        ::: {.cell}\n        \n        ```{.r .cell-code}\n        library(DT)\n        \n        Value = c(1.3, 2.1, 3.5, 4.1, 5.2)\n        Frequency = c(2, 3, 1, 4, 2)\n        \n        my_data <- data.frame(\n          Value,\n          Frequency,\n          Weight = Frequency / sum(Frequency)\n        )\n        \n        datatable(\n          my_data, \n          options = list(\n            dom = \"t\",\n            columnDefs = list(\n              list(\n              className = \"dt-center\",\n              targets = \"_all\"\n              )\n            )\n          ),\n          rownames = FALSE\n        )\n        ```\n        \n        ::: {.cell-output-display}\n        \n        ```{=html}\n        <div class=\"datatables html-widget html-fill-item\" id=\"htmlwidget-493568ce41f2606ee860\" style=\"width:100%;height:auto;\"></div>\n        <script type=\"application/json\" data-for=\"htmlwidget-493568ce41f2606ee860\">{\"x\":{\"filter\":\"none\",\"vertical\":false,\"data\":[[1.3,2.1,3.5,4.1,5.2],[2,3,1,4,2],[0.1666666666666667,0.25,0.08333333333333333,0.3333333333333333,0.1666666666666667]],\"container\":\"<table class=\\\"display\\\">\\n  <thead>\\n    <tr>\\n      <th>Value<\\/th>\\n      <th>Frequency<\\/th>\\n      <th>Weight<\\/th>\\n    <\\/tr>\\n  <\\/thead>\\n<\\/table>\",\"options\":{\"dom\":\"t\",\"columnDefs\":[{\"className\":\"dt-center\",\"targets\":\"_all\"},{\"name\":\"Value\",\"targets\":0},{\"name\":\"Frequency\",\"targets\":1},{\"name\":\"Weight\",\"targets\":2}],\"order\":[],\"autoWidth\":false,\"orderClasses\":false}},\"evals\":[],\"jsHooks\":[]}</script>\n        ```\n        \n        :::\n        :::\n\n\n\n        <br>\n\n        -   The weighted mean is calculated as:\n\n        $$\n        \\bar{x} = \\displaystyle \\frac{2 \\times 1.3 + 3 \\times 2.1 + 1 \\times 3.5 + 4 \\times 4.1 + 2 \\times 5.2}{2 + 3 + 1 + 4 + 2} = \n        $$\n\n        $$\n        \\frac{2.6 + 6.3 + 3.5 + 16.4 + 10.4}{12} = \\frac{39.2}{12} \\approx 3.27\n        $$\n\n        -   It can also be calculated using the `weights` as follows:\n\n\n\n            ::: {.cell}\n            \n            ```{.r .cell-code}\n            with(my_data, sum(Value * Weight))\n            ```\n            \n            ::: {.cell-output .cell-output-stdout}\n            \n            ```\n            [1] 3.266667\n            ```\n            \n            \n            :::\n            :::\n\n\n\n        -   The built-in R function `weighted.mean()` can be used for direct calculation:\n\n\n\n            ::: {.cell}\n            \n            ```{.r .cell-code}\n            weighted.mean(\n              x = my_data$Value, \n              w = my_data$Frequency)  # w represents the weights which can be given as frequencies or weights\n            ```\n            \n            ::: {.cell-output .cell-output-stdout}\n            \n            ```\n            [1] 3.266667\n            ```\n            \n            \n            :::\n            :::\n\n\n\n#### Characteristics of the mean\n\n1.  The sum of deviations of the observations from the arithmetic mean is always zero:\n\n$$\n\\displaystyle \\sum_{i=1}^{n} (x_i - \\bar{x}) = 0\n$$\n\n2.  The sum of the squared deviations of the observations from a certain value is the least (i.e., minimized) when this value is the mean (this is referred to as the `least squares principle`).\n\n3.  If a constant $c$ is added to each observation, the mean is also increased by $c$, i.e., the mean of $x_i + c = \\bar{x} + c$.\n\n4.  If the observations are multiplied by a constant $c$, then the mean is also multiplied by $c$, i.e., the mean of $cx_i = c\\bar{x}$.\n\n5.  If the observations $x_1, x_2, \\ldots x_n$ are linearly transformed, where $y_i = a + bx_i$ ($a$ and $b$ are known constants), then it holds that $\\bar{y} = a + b\\bar{x}$.\n\n6.  The mean is sensitive to extreme values (outliers), and it may not be a good measure of central tendency in the presence of outliers.\n\n    ::: {#lst-outlier lst-cap=\"Impact of outliers on the mean\"}\n    -   Example: consider the following variable with values $(32.1,\\ 34.5,\\ 33.6,\\ 37.2,\\ 39.4)$ the mean is calculated as follows:\n\n\n\n        ::: {.cell}\n        \n        ```{.r .cell-code}\n        x <- c(32.1, 34.5, 33.6, 37.2, 39.4)\n        mean(x)\n        ```\n        \n        ::: {.cell-output .cell-output-stdout}\n        \n        ```\n        [1] 35.36\n        ```\n        \n        \n        :::\n        :::\n\n\n\n        -   Lets replace the last value with an extreme value of $250.1$, so the values would be:\n\n\n\n            ::: {.cell}\n            \n            ```{.r .cell-code}\n            x[5] <- 250.1\n            x\n            ```\n            \n            ::: {.cell-output .cell-output-stdout}\n            \n            ```\n            [1]  32.1  34.5  33.6  37.2 250.1\n            ```\n            \n            \n            :::\n            :::\n\n\n\n        -   The mean of the new values with the outlier would be:\n\n\n\n            ::: {.cell}\n            \n            ```{.r .cell-code}\n            mean(x)\n            ```\n            \n            ::: {.cell-output .cell-output-stdout}\n            \n            ```\n            [1] 77.5\n            ```\n            \n            \n            :::\n            :::\n\n\n\n        -   The presence of the outlier affected the mean that it is no longer a good measure of central tendency for this variable.\n    :::\n\n### Median {#median}\n\n-   The median, denoted by $\\large \\tilde{x}_{0.5}$, is the value which divides the ordered observations into two equal parts (i.e., at least 50% of the values $\\ge$ the median and at least 50% of the values $\\le$ the median).\n\n-   The median is calculated as follows:\n\n    -   If the number of observations is odd, the median is the middle value of the ordered observations.\n\n    -   If the number of observations is even, the median is the arithmetic mean of the two middle observations.\n\n$$\n\\tilde{x}_{0.5} = \\begin{cases} x_{\\frac{n+1}{2}} & \\text{if $n$ is odd} \\\\ \\\\ \\frac{1}{2}(x_{\\frac{n}{2}} + x_{\\frac{n}{2}+1}) & \\text{if $n$ is even} \\end{cases}\n$$\n\n::: panel-tabset\n## Example B.3.1 {{< iconify ic:round-menu-book size=21px >}}\n\n-   Consider the following set of observations: $(3, 5, 7, 7, 7, 9, 11)$.\n\n    -   There is an odd number of observations $n = 7$, so the median is the middle value of the ordered observations, which is ranked $\\displaystyle \\frac{n+1}{2} = \\frac{7+1}{2}=4^{th}$ and its value is $7$.\n\n    -   Half of the measurements $(3, 5, 7)$ are below or equal to $7$, and half of the measurements $(7, 9, 11)$ are equal to or above $7$.\n\n    -   Therefore, the previous defintion of the [median](#median) contains \"equal to\" to cover the case of having repeated, similar values.\n\n## Example B.3.2 {{< iconify ic:round-menu-book size=21px >}}\n\n-   Example: the variable `mpg` has $32$ observations, so the median is the arithmetic mean of the two middle observations (i.e., the mean of the ordered observations ranked $\\displaystyle \\frac{32}{2} = 16^{th}$ and $\\displaystyle \\frac{32}{2} + 1 =17^{th}$):\n\n    -   The ordered observations are:\n\n\n\n        ::: {.cell}\n        \n        ```{.r .cell-code}\n        mpg_ordered <- sort(mtcars$mpg)\n        mpg_ordered\n        ```\n        \n        ::: {.cell-output .cell-output-stdout}\n        \n        ```\n         [1] 10.4 10.4 13.3 14.3 14.7 15.0 15.2 15.2 15.5 15.8 16.4 17.3 17.8 18.1 18.7\n        [16] 19.2 19.2 19.7 21.0 21.0 21.4 21.4 21.5 22.8 22.8 24.4 26.0 27.3 30.4 30.4\n        [31] 32.4 33.9\n        ```\n        \n        \n        :::\n        :::\n\n\n\n    -   The $16^{th}$ and $17^{th}$ ordered observations are:\n\n\n\n        ::: {.cell}\n        \n        ```{.r .cell-code}\n        mpg_ordered[16:17]\n        ```\n        \n        ::: {.cell-output .cell-output-stdout}\n        \n        ```\n        [1] 19.2 19.2\n        ```\n        \n        \n        :::\n        :::\n\n\n\n    -   The median is the arithmetic mean of these two values:\n\n\n\n        ::: {.cell}\n        \n        ```{.r .cell-code}\n        mean(mpg_ordered[16:17])\n        ```\n        \n        ::: {.cell-output .cell-output-stdout}\n        \n        ```\n        [1] 19.2\n        ```\n        \n        \n        :::\n        :::\n\n\n\n    -   The median can also be calculated using the built-in R function `median()`:\n\n\n\n        ::: {.cell}\n        \n        ```{.r .cell-code}\n        median(mtcars$mpg)\n        ```\n        \n        ::: {.cell-output .cell-output-stdout}\n        \n        ```\n        [1] 19.2\n        ```\n        \n        \n        :::\n        :::\n\n\n:::\n\n#### Characteristics of the median\n\n-   Unlike the mean, the median is not drastically affected by extreme values (outliers).\n\n-   Consider the example discussed above @lst-outlier:\n\n    -   The median of the original set of observations is:\n\n\n\n        ::: {.cell}\n        \n        ```{.r .cell-code}\n        median(c(32.1, 34.5, 33.6, 37.2, 39.4))\n        ```\n        \n        ::: {.cell-output .cell-output-stdout}\n        \n        ```\n        [1] 34.5\n        ```\n        \n        \n        :::\n        :::\n\n\n\n    -   The median of the set of observations with the outlier is:\n\n\n\n        ::: {.cell}\n        \n        ```{.r .cell-code}\n        median(c(32.1, 34.5, 33.6, 37.2, 250.1))\n        ```\n        \n        ::: {.cell-output .cell-output-stdout}\n        \n        ```\n        [1] 34.5\n        ```\n        \n        \n        :::\n        :::\n\n\n\n    -   Becuase the median is concerned with the middle value, it is less affected by the presence of the outliers than the mean.\n\n### Quantiles\n\n-   Quantiles are a generalization of of the concept of the median.\n\n-   A quantile is defined as the value that divides the ordered observations into two parts such that a certain proportion of the observations are less than or equal to the quantile.\n\n-   In this sense, the median is the $50^{th}$ quantile because at least $50\\%$ of the observations are less than or equal to the median.\n\n-   Similarly, the $20^{th}$ quantile is the value that divides the ordered observations into two parts such that at least $20\\%$ of the observations are less than or equal to the that quantile, while at least $80\\%$ of the observations are greater than or equal to that quantile.\n\n::: {.callout-note style=\"color: #0466c8;\" title=\"General definition of quantiles\"}\n-   Let $\\alpha$ be a number between $0$ and $1$.\n\n-   The $[(\\alpha \\times 100)\\%$ quantile is denoted by $\\large \\tilde{x}_{\\alpha}$.\n\n-   It is defined as the value that splits the data into two parts such that at least $\\alpha \\times 100\\%$ of the observations are less than or equal to the quantile, while at least $(1 - \\alpha) \\times 100\\%$ of the observations are greater than or equal to the quantile.\n:::\n\n-   **Deciles** divide the data into $10$ parts, corresponding to quantiles at $\\alpha = 0.1, 0.2, \\ldots, 0.9$.\n\n-   **Quintiles** divide the data into $5$ parts, corresponding to quantiles at $\\alpha = 0.2, 0.4, 0.6, 0.8$.\n\n-   **Quartiles** divide the data into $4$ parts, corresponding to quantiles at $\\alpha = 0.25, 0.5, 0.75$.\n\n-   **Percentiles**: if $(\\alpha \\times 100)$ takes an integer value, the quantile is referred to as a percentile (i.e, divide the data into $100$ equal parts).\n\n#### Calculation of quantiles\n\n-   The quantiles can be obtained in R using the `quantile()` function.\n\n-   For example, the quantiles of the variable `mpg` in the `mtcars` dataset can be calculated as follows:\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    quantile(mtcars$mpg)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n        0%    25%    50%    75%   100% \n    10.400 15.425 19.200 22.800 33.900 \n    ```\n    \n    \n    :::\n    :::\n\n\n\n-   By default, The function outputs the $0^{th}$, $25^{th}$, $50^{th}$, $75^{th}$, and $100^{th}$ quantiles (i.e., the minimum, first quartile, median, third quartile, and maximum).\n\n-   To get a specific quantile, use the `probs` argument to add a vector of the desired probabilities (i.e., $\\alpha$). For example, the following code can be used to get the $5^{th}$ and $95^{th}$ quantiles:\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    quantile(\n      mtcars$mpg, \n      probs = c(0.05, 0.95)\n    )\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n        5%    95% \n    11.995 31.300 \n    ```\n    \n    \n    :::\n    :::\n\n\n\n-   R provides **nine** algorithms to calculate the quantiles, which can be specified using the `type` argument:\n\n    -   Types $1-3$ are used for discontinuous data, while types $4-9$ are used for continuous data.\n\n    -   Type $1$ and $3$ are used for class \"Date\" and for ordered factors.\n\n    -   Type $7$ is the default method for continous data.\n\n    -   Type $6$ is used to get results similar to `SPSS`, `Minitab`, or `Graphpad Prism`.\n\n    -   For example, the of $25^{th}$ and $75^{th}$ quantiles of the variable `mpg` in the `mtcars` dataset using `R` (type $6$ or $7$), `SPSS`, and, `Graphpad Prism` are as follows:\n\n        ::: panel-tabset\n        ## R\n\n        -   Using type $6$:\n\n\n\n        ::: {.cell}\n        \n        ```{.r .cell-code}\n        quantile(\n        mtcars$mpg, \n        probs = c(0.25, 0.75),\n        type = 6\n        )\n        ```\n        \n        ::: {.cell-output .cell-output-stdout}\n        \n        ```\n           25%    75% \n        15.275 22.800 \n        ```\n        \n        \n        :::\n        :::\n\n\n\n        -   Using type $7$:\n\n\n\n        ::: {.cell}\n        \n        ```{.r .cell-code}\n        quantile(\n        mtcars$mpg, \n        probs = c(0.25, 0.75),\n        type = 7\n        )\n        ```\n        \n        ::: {.cell-output .cell-output-stdout}\n        \n        ```\n           25%    75% \n        15.425 22.800 \n        ```\n        \n        \n        :::\n        :::\n\n\n\n        ## SPSS\n\n        <img src=\"/images/quantile_A.png\" alt=\"SPSS\" width=\"100%\"/>\n\n        ## Graphpad Prism\n\n        <img src=\"/images/quantile_B.png\" alt=\"Graphpad Prism\" width=\"80%\"/>\n        :::\n\n    -   Detailed discussion of the algorithms used to calculate the quantiles can be found [here](/posts/biostats/B004_desc_stats.qmd).\n\n### Mode\n\n-   The mode of a set of observations is the observation that occurs most frequently compared with all other values.\n\n-   A set of observations can have:\n\n    -   No mode (if all observations occur with the same frequency).\n\n    -   One mode (if one observation occurs most frequently).\n\n    -   More than one mode (if two or more observations occur with the same highest frequency).\n\n-   Example: consider the variable `cyl` (number of car cylinders) in the `mtcars` dataset:\n\n    -   R has no direct built-in function to calculate the mode, but it can be calculated from the frequency table as follows:\n\n\n\n        ::: {.cell}\n        \n        ```{.r .cell-code}\n        library(dplyr)\n        # create table of the frequencies of the values\n        freq_tbl <- table(mtcars$cyl)\n        \n        # convert to adata frame\n        freq_df <- as.data.frame(freq_tbl)\n        names(freq_df)[1] <- \"cyl\"\n        \n        # arrange the values in descending order of frequency\n        freq_df <- \n          freq_df %>% \n            arrange(desc(Freq))\n            \n        freq_df\n        ```\n        \n        ::: {.cell-output .cell-output-stdout}\n        \n        ```\n          cyl Freq\n        1   8   14\n        2   4   11\n        3   6    7\n        ```\n        \n        \n        :::\n        \n        ```{.r .cell-code}\n        paste(\n          \"The mode is\", \n          freq_df$cyl[which.max(freq_df$Freq)], \n          \"cyliners\"\n        )\n        ```\n        \n        ::: {.cell-output .cell-output-stdout}\n        \n        ```\n        [1] \"The mode is 8 cyliners\"\n        ```\n        \n        \n        :::\n        :::\n\n\n\n    -   The mode can also be calculated directly using the `Mode()` function from the `DescTools` package:\n\n\n\n        ::: {.cell}\n        \n        ```{.r .cell-code}\n        library(DescTools)\n        Mode(mtcars$cyl)\n        ```\n        \n        ::: {.cell-output .cell-output-stdout}\n        \n        ```\n        [1] 8\n        attr(,\"freq\")\n        [1] 14\n        ```\n        \n        \n        :::\n        :::\n\n\n\n        -   The first line of the output shows the mode ($8$ cylinders) and the last line shows the frequency of the mode.\n\n    ::: callout-caution\n    -   R has a built-in function `mode()` that returns the storage mode of an object (e.g., numeric, character, etc.) rather than the mode.\n\n\n\n        ::: {.cell}\n        \n        ```{.r .cell-code}\n        mode(mtcars$cyl)\n        ```\n        \n        ::: {.cell-output .cell-output-stdout}\n        \n        ```\n        [1] \"numeric\"\n        ```\n        \n        \n        :::\n        :::\n\n\n    :::\n\n    -   For numerical data which contains many unique values, the mode may not be a good measure of central tendency. However, if the observations are summarized in groups (e.g., frequency table or histogram), the mode can be calculated as the class interval with the highest frequency.\n\n        -   Example: consider the histogram of the variable `mpg` in the `mtcars` dataset:\n\n\n\n            ::: {.cell}\n            ::: {.cell-output-display}\n            ![](B003_desc_stats_files/figure-html/unnamed-chunk-27-1.png){width=672}\n            :::\n            :::\n\n\n\n            -   The class interval $(15, 20]$ has the highest frequency of $12$ observations, so the mode is the interval $(15, 20]$ (others may also consider the midpoint of the interval, $17.5$, as the mode).\n\n### Geometric mean\n\n-   Let $X$ a quantitative random variable with `positive` and `non-zero` values $x_1, x_2, \\ldots, x_n$, then the geometric mean $(\\bar{x}_G)$ is computed by multiplying all the values and then taking the $n^{th}$ root of the product:\n\n    $$\n    \\bar{x}_G = \\large \\sqrt[n]{x_1 \\times x_2 \\times \\ldots \\times x_n} = \\left( \\displaystyle \\prod_{i=1}^{n} x_i \\right)^{\\frac{1}{n}} \n    $$\n\n-   It is less sensitive to extreme values in skewed distributions than the arithmetic mean.\n\n-   Geometric mean is used for averaging data that are `multiplicative` in nature (e.g., percentage change and rates).\n\n    -   **Percentage change** is calculated as the difference between the final $(x_1)$ and initial $(x_0)$ values divided by the initial value, then multiplied by $100$:\n\n        $$\n            \\displaystyle \\text{Percentage change} = \\left( \\frac{x_1 - x_0}{x_0} \\right) \\times 100\n        $$\n\n        -   If the sign of the percentage change is positive, it indicates an increase, while a negative sign indicates a decrease.\n\n    -   **Rate** is the ratio of two quantities that describes how one quantity changes with respect to another (e.g., speed, growth rate, and interest rate).\n\n::: panel-tabset\n## Example B.3.3 {{< iconify ic:round-menu-book size=21px >}}\n\n-   Consider the following set of observations: $(4, 16, 64, 256)$.\n\n-   The geometric mean is calculated as:\n\n    $$\n      \\sqrt[4]{4 \\times 16 \\times 64 \\times 256} = \\sqrt[4]{1048576} = 32\n    $$\n\n-   The geometric mean can be calculated using the `Gmean()` function from the `DescTools` package or the `geometric.mean()` function from the `psych` package:\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    library(DescTools)\n    library(psych)\n    x <- c(4, 16, 64, 256)\n    Gmean(x)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] 32\n    ```\n    \n    \n    :::\n    \n    ```{.r .cell-code}\n    geometric.mean(x)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] 32\n    ```\n    \n    \n    :::\n    :::\n\n\n\n## Example B.3.4 {{< iconify ic:round-menu-book size=21px >}}\n\n-   Assume a bank provides the following interest rates for a three-year plan: $3.3\\%$ in the first year, $4.5\\%$ in the second year, and $5.2\\%$ in the third year.\n\n-   If a client deposits $\\textdollar{500}$, the change in the amount can be calculated as follows:\n\n    | Time | Year | Amount $(\\textdollar)$ | Rate $(\\%)$ | Interest $(\\textdollar)$ $(\\text{Rate}_t \\times \\text{Amount}_{t-1})$ | Growth factor $(\\text{Amount}_t/\\text{Amount}_{t-1})$ |\n    |:--:|:--:|:--:|:--:|:--:|:--:|\n    | $t_0$ | 0 | $500.0$ | – | – | – |\n    | $t_1$ | 1 | $516.5$ | $3.3$ | $16.5$ | $1.033$ |\n    | $t_2$ | 2 | $539.7$ | $4.5$ | $23.2$ | $1.045$ |\n    | $t_3$ | 3 | $567.8$ | $5.2$ | $28.1$ | $1.052$ |\n\n-   The interest rate is also known as the `growth rate`.\n\n-   The growth rate $= (\\text{growth factor} - 1) \\times 100$.\n\n-   The average growth factor is calculated as the geometric mean of the growth factors:\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    growth_factors <- c(1.033, 1.045, 1.052)\n    Gmean(growth_factors)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] 1.043304\n    ```\n    \n    \n    :::\n    :::\n\n\n\n-   So, the average growth rate per year $= (1.043 - 1) \\times 100 = 4.3\\%$.\n\n-   This average growth rate can also be obtained by calculating the geometric mean of the interest (growth) rates:\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    interest_rates <- c(3.3, 4.5, 5.2)\n    Gmean(interest_rates)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] 4.258369\n    ```\n    \n    \n    :::\n    :::\n\n\n\n-   However, this approach is not recommended because the interest rates can be negative (the rate decreases), which results in error while computing the geometric mean.\n\n-   The total amount of money ($A$) can be calculated at any year using the formula: $A_t = A_{t_0} \\times (\\text{average growth factor}) \\large ^t$. For example, the amount at the end of the third year $= 500 \\times 1.043304^3 = \\textdollar567.8$.\n\n## [Exercise B.3.1 {{< iconify fluent:chat-bubbles-question-20-filled size=21px >}}]{style=\"color: #ba181b\"}\n\n-   Calculate the average interest rate for the following four-year plan: $10\\%$, $14\\%$, $15\\%$, and $-5\\%$.\n\n    The average rate per year is <input class='webex-solveme nospaces' size='3' data-answer='[\"8.2\"]'/> $\\%$ (to one decimal place)\n\n\n<div class='webex-solution'><button>Click to show/hide answer</button>\n\n\n-   The average interest rate can not be computed directly by calculating the geometric mean of the interest rates because the last rate is negative.\n\n-   Therefore, we calculate the average growth factor as the geometric mean of the growth factors.\n\n-   Growth factor $= \\displaystyle \\frac{\\text{rate}}{100} + 1$\n\n-   So, the growth factors are $(1.1, 1.14, 1.15, 0.95)$.\n\n-   The average growth factor is equal to:\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    growth_factors <- c(1.1, 1.14, 1.15, 0.95)\n    Gmean(growth_factors)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] 1.081882\n    ```\n    \n    \n    :::\n    :::\n\n\n\n-   Therefore, the average interest rate per year is $8.2\\%$.\n\n\n</div>\n\n:::\n\n#### Geometric mean and logarihmic transformation\n\n-   If the observations are transformed by taking the logarithm (common or natural), [the antilogarithm of the arithmetic mean of the transformed values]{style=\"color: #0466c8\"} is equal to [the geometric mean of the original values]{style=\"color: #ba181b\"}.\n\n    -   Let $X$ be a random variable with positive, non-zero values $x_1, x_2, \\ldots, x_n$, and $Y$ is the transformed variable with values $y_1, y_2, \\ldots, y_n$ such that $y_i = \\log_{10}(x_i)$:\n\n    -   The arithmetic mean of the transformed values is calculated as:\n\n    $$\n     \\bar{y} = \\displaystyle \\frac{y_1 + y_2 + \\ldots + y_n}{n} = \\displaystyle \\frac{\\log_{10}(x_1) + \\log_{10}(x_2) + \\ldots + \\log_{10}(x_n)}{n} = \n    $$\n\n    $$\n    \\log_{10} \\left( \\sqrt[n]{x_1 \\times x_2 \\times \\ldots \\times x_n} \\right)\n    $$\n\n    -   The antilogarithm of the arithmetic mean of the transformed values is:\n\n    $$\n     10^{\\bar{y}} = 10^{\\log_{10} \\left( \\sqrt[n]{x_1 \\times x_2 \\times \\ldots \\times x_n} \\right)} = \\sqrt[n]{x_1 \\times x_2 \\times \\ldots \\times x_n}\n    $$\n\n    -   The last equation represents the geometric mean of the original values.\n\n-   Example: consider the following set of observations $(5,\\ 9,\\ 10,\\ 22,\\ 13, 50)$, the following table shows the original and $log_{10}$ transformed values:\n\n    :::::: grid\n    ::: g-col-2\n    :::\n\n    ::: g-col-8\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    library(DT)\n    x <- c(5, 9, 10, 22, 13, 50)\n    y <- round(log10(x), 5)\n    \n    my_data <- data.frame(\n      Original = x,\n      Log10_transformed = y\n    )\n    \n    datatable(\n      my_data, \n      options = list(\n        dom = \"t\",\n        columnDefs = list(\n          list(\n          className = \"dt-center\",\n          targets = \"_all\"\n          )\n        )\n      ),\n      rownames = FALSE\n    )\n    ```\n    \n    ::: {.cell-output-display}\n    \n    ```{=html}\n    <div class=\"datatables html-widget html-fill-item\" id=\"htmlwidget-59282717eb2eff9be3e8\" style=\"width:100%;height:auto;\"></div>\n    <script type=\"application/json\" data-for=\"htmlwidget-59282717eb2eff9be3e8\">{\"x\":{\"filter\":\"none\",\"vertical\":false,\"data\":[[5,9,10,22,13,50],[0.69897,0.95424,1,1.34242,1.11394,1.69897]],\"container\":\"<table class=\\\"display\\\">\\n  <thead>\\n    <tr>\\n      <th>Original<\\/th>\\n      <th>Log10_transformed<\\/th>\\n    <\\/tr>\\n  <\\/thead>\\n<\\/table>\",\"options\":{\"dom\":\"t\",\"columnDefs\":[{\"className\":\"dt-center\",\"targets\":\"_all\"},{\"name\":\"Original\",\"targets\":0},{\"name\":\"Log10_transformed\",\"targets\":1}],\"order\":[],\"autoWidth\":false,\"orderClasses\":false}},\"evals\":[],\"jsHooks\":[]}</script>\n    ```\n    \n    :::\n    :::\n\n\n    :::\n\n    ::: g-col-2\n    :::\n    ::::::\n\n    <br>\n\n    -   The arithmetic mean of the transformed values is:\n\n\n\n        ::: {.cell}\n        \n        ```{.r .cell-code}\n        mean(y)\n        ```\n        \n        ::: {.cell-output .cell-output-stdout}\n        \n        ```\n        [1] 1.134757\n        ```\n        \n        \n        :::\n        :::\n\n\n\n    -   The antilogarithm of the arithmetic mean of the transformed values is:\n\n\n\n        ::: {.cell}\n        \n        ```{.r .cell-code}\n        10^mean(y)\n        ```\n        \n        ::: {.cell-output .cell-output-stdout}\n        \n        ```\n        [1] 13.63819\n        ```\n        \n        \n        :::\n        :::\n\n\n\n    -   The geometric mean of the original values is:\n\n\n\n        ::: {.cell}\n        \n        ```{.r .cell-code}\n        Gmean(x)\n        ```\n        \n        ::: {.cell-output .cell-output-stdout}\n        \n        ```\n        [1] 13.63823\n        ```\n        \n        \n        :::\n        :::\n\n\n\n    -   The antilogarithm of the arithmetic mean of the transformed values is equal to the geometric mean of the original values.\n\n    ::: {.callout-note style=\"color: #0466c8;\"}\n    -   When the original values are log transformed, the back-transformed mean is not the same as the original mean but it is the geometric mean of the original values.\n\n    -   On the other hand, back-transforming the median of the log-transformed values gives the median of the original values:\n\n        -   For the `mpg` variable from the `mtcars` dataset, the median of the log-transformed values is:\n\n\n\n            ::: {.cell}\n            \n            ```{.r .cell-code}\n            med_log <- median(\n              log(mtcars$mpg))\n            med_log\n            ```\n            \n            ::: {.cell-output .cell-output-stdout}\n            \n            ```\n            [1] 2.95491\n            ```\n            \n            \n            :::\n            :::\n\n\n\n        -   The antilogarithm of the median (back transformation) of the log-transformed values is:\n\n\n\n            ::: {.cell}\n            \n            ```{.r .cell-code}\n            exp(med_log) # exponentiation to back transform\n            ```\n            \n            ::: {.cell-output .cell-output-stdout}\n            \n            ```\n            [1] 19.2\n            ```\n            \n            \n            :::\n            :::\n\n\n\n        -   The median of the original values is:\n\n\n\n            ::: {.cell}\n            \n            ```{.r .cell-code}\n            median(mtcars$mpg)\n            ```\n            \n            ::: {.cell-output .cell-output-stdout}\n            \n            ```\n            [1] 19.2\n            ```\n            \n            \n            :::\n            :::\n\n\n\n        -   The antilogarithm of the median of the log-transformed values is equal to the median of the original values.\n    :::\n\n### Harmonic mean\n\n-   The harmonic mean $(\\bar{x}_H)$ is the reciprocal of the arithmetic mean of the reciprocals of the observations:\n\n    -   Let $X$ be a random variable with values $x_1, x_2, \\ldots, x_n$, then the reciprocals of the observations are $\\displaystyle \\frac{1}{x_1}, \\frac{1}{x_2}, \\ldots, \\frac{1}{x_n}$, and their arithmetic mean is calculated as:\n\n    $$\n    \\displaystyle \\frac{1}{n} \\left( \\displaystyle \\frac{1}{x_1} + \\displaystyle \\frac{1}{x_2} + \\ldots + \\displaystyle \\frac{1}{x_n} \\right) = \\displaystyle \\frac{\\displaystyle \\sum_{i=1}^{n} \\frac{1}{x_i}}{n}\n     $$\n\n    -   The harmonic mean is the reciprocal of the arithmetic mean of the reciprocals:\n\n    $$\n     \\bar{x}_H = \\displaystyle \\frac{n}{\\displaystyle \\sum_{i=1}^{n} \\frac{1}{x_i}}\n     $$\n\n-   It is used for averaging data that are `ratios` or `rates` (e.g., speed or financial ratios).\n\n-   If the observations do not contribute equally towards the calculation of the mean (i.e., the observations have different weights), the harmonic mean can be weighted:\n\n    -   Let $X$ be a random variable with values $x_1, x_2, \\ldots, x_n$ that have coressponding weights $w_1, w_2, \\ldots, w_n$, then the harmonic mean is calculated as:\n\n    $$\n    \\text{Weighted}\\ \\bar{x}_H = \\displaystyle \\frac{w_1 + w_2 + \\ldots + w_n}{\\displaystyle \\frac{w_1}{x_1} + \\frac{w_2}{x_2} + \\ldots + \\frac{w_n}{x_n}} = \\displaystyle \\frac{\\displaystyle  \\sum_{i=1}^{n} w_i}{\\displaystyle \\sum_{i=1}^{n} \\frac{w_i}{x_i}} = \\displaystyle \\frac{1}{\\displaystyle \\sum_{i=1}^{n} \\frac{w_i}{x_i}} \n    $$\n\n-   Example: consider the following set of observations $(2, 4, 6, 8)$:\n\n    -   The harmonic mean is calculated as:\n\n\n\n        ::: {.cell}\n        \n        ```{.r .cell-code}\n        x <- c(2, 4, 6, 8)\n        n <- length(x)\n        harmonic_mean <- n / sum(1 / x)\n        harmonic_mean\n        ```\n        \n        ::: {.cell-output .cell-output-stdout}\n        \n        ```\n        [1] 3.84\n        ```\n        \n        \n        :::\n        :::\n\n\n\n    -   The harmonic mean can also be calculated using the `Hmean()` function from the `DescTools` package or `harmonic.mean()` function from the `psych` package:\n\n\n\n        ::: {.cell}\n        \n        ```{.r .cell-code}\n        library(DescTools)\n        Hmean(x)\n        ```\n        \n        ::: {.cell-output .cell-output-stdout}\n        \n        ```\n        [1] 3.84\n        ```\n        \n        \n        :::\n        \n        ```{.r .cell-code}\n        library(psych)\n        harmonic.mean(x)\n        ```\n        \n        ::: {.cell-output .cell-output-stdout}\n        \n        ```\n        [1] 3.84\n        ```\n        \n        \n        :::\n        :::\n\n\n\n-   The harmonic mean is used to calculate some statistical measures such as F1 score used to assess the performance of logistic regression models. In addition, it is used during pairwise multiple comparisons.\n\n:::: panel-tabset\n## Example B.3.5 {{< iconify ic:round-menu-book size=21px >}}\n\nA car travels $100\\ \\text{km}$ at a speed $60\\ \\text{km/h}$, $100\\  \\text{km}$ at $70\\ \\text{km/h}$, $100\\ \\text{km}$ at $90\\ \\text{km/h}$, and $100\\ \\text{km}$ at $100\\ \\text{km/h}$. Calculate the average speed of the car.\n\n-   The arithmetic mean of the speed $= \\displaystyle \\frac{60 + 70 + 90 +100}{4} = \\frac{320}{4} = 80$ km/h.\n\n-   However, this method ignores the time taken to travel each distance.\n\n-   The time taken to travel each distance is given in the following table:\n\n| Speed (km/h) | Distanc (km) | Time (h) \\[Distance/Speed\\] |\n|:------------:|:------------:|:---------------------------:|\n|     $60$     |    $100$     |         $1.666667$          |\n|     $70$     |    $100$     |         $1.428571$          |\n|     $90$     |    $100$     |         $1.111111$          |\n|    $100$     |    $100$     |             $1$             |\n\n-   The total distance traveled is $400$ km, and the total time taken is $5.21\\ \\text{h}$ So, the actual average speed $= \\displaystyle \\frac{400}{5.206349} \\approx 76.83\\ \\text{km/h}$.\n\n-   This average can be found using the harmonic mean of the speeds:\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    speeds <- c(60, 70, 90, 100)\n    Hmean(speeds)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] 76.82927\n    ```\n    \n    \n    :::\n    :::\n\n\n\n-   The average speed can also be calculated as the weighted arithmetic mean using weights based on the time taken to travel each distance:\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    times <- c(100/60, 100/70, 100/90, 100/100) # use times as weights\n    weighted.mean(speeds, w = times)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] 76.82927\n    ```\n    \n    \n    :::\n    :::\n\n\n\n::: {.callout-note style=\"color: #0466c8;\"}\n-   To find the average of rates with different numerators but the same denominator use the arithmetic mean or weighted harmonic mean (weights are based on numerators).\n\n-   To find the average of rates with same numerators but different denominators use the harmonic mean or weighted arithmetic mean (weights are based on denominators).\n\n-   To find the average of rates with different numerators and denominators use the weighted arithmetic mean (weights are based on denominators) or weighted harmonic mean (weights are based on numerators).\n:::\n\n## Example B.3.6 {{< iconify ic:round-menu-book size=21px >}}\n\nSuppose that you invested $\\textdollar{2550}$ in stock market. In the first year, you spent $\\textdollar{1000}$ to purchase $40$ shares of stock $A$. In the second year, you spent $\\textdollar{1550}$ to purchase $78$ shares of the same stock. Calculate the average price per share.\n\n-   The rate here is the price $(\\textdollar)$ per share.\n\n-   The total amount of the shares bought $= 40 + 78 = 118$ shares, so the actual average price per share $= \\displaystyle \\frac{2550}{118} \\approx \\textdollar{21.61}$.\n\n-   In the first year, the price per share $= \\displaystyle \\frac{1000}{40} = \\textdollar{25}$.\n\n-   In the second year, the price per share $= \\displaystyle \\frac{1550}{78} \\approx \\textdollar{19.87}$.\n\n| Year | Price per share $(\\textdollar/\\text{share})$ | Amount invested $(\\textdollar)$ | Number of shares |\n|:--:|:--:|:--:|:--:|\n| $1$ | $25.00$ | $1000$ | $40$ |\n| $2$ | $19.87$ | $1550$ | $78$ |\n\n-   The arithmetic mean of the price per share $= \\displaystyle \\frac{25 + 19.87}{2} = \\displaystyle \\frac{44.87}{2} = \\textdollar{22.44}$, which is higher than the actual average price per share.\n\n-   Because both the numerator (amount invested) and denominator (number of shares) are different, the weighted arithmetic or weighted harmonic mean should be used to calculate the average price per share:\n\n    -   The weighted arithmetic mean using denominator (number of shares) as weights:\n\n\n\n        ::: {.cell}\n        \n        ```{.r .cell-code}\n        weights_1 <- c(40/118, 78/118)\n        price_1 <- 1000/40\n        price_2 <- 1550/78\n        weighted.mean(c(price_1, price_2), w = weights_1)\n        ```\n        \n        ::: {.cell-output .cell-output-stdout}\n        \n        ```\n        [1] 21.61017\n        ```\n        \n        \n        :::\n        :::\n\n\n\n    -   The weighted harmonic mean using numerators (amount invested) as weights:\n\n\n\n        ::: {.cell}\n        \n        ```{.r .cell-code}\n        weights_2 <- c(1000/2550, 1550/2550)\n        h_mean <- 1/sum(weights_2 / c(price_1, price_2))\n        h_mean\n        ```\n        \n        ::: {.cell-output .cell-output-stdout}\n        \n        ```\n        [1] 21.61017\n        ```\n        \n        \n        :::\n        :::\n\n\n::::\n\n### Trimmed mean\n\n-   The observations are arranged based on magnitude, then a certain percentage of the observations are removed from both ends of the ordered observations.\n\n-   The trimmed mean $(\\bar{x}_T)$ is then calculated as the arithmetic mean of the remaining observations.\n\n-   Typically, $5\\%$ to $25\\%$ of the observations are trimmed from each end.\n\n-   The trimmed mean is less sensitive to outliers than the arithmetic mean becuase the extreme values are removed.\n\n-   Some robust statistical tests use the trimmed mean such as **Yuen's test**, which is used to compare the trimmed means of two groups when the assumption of normality is violated.\n\n-   Trimmed mean can be calculated in R using the `mean()` function with the `trim` argument set to the percentage of observations to be trimmed.\n\n    -   Example: the $5\\%$ trimmed mean of the variable `mpg` in the `mtcars` dataset is calculated as follows:\n\n\n\n        ::: {.cell}\n        \n        ```{.r .cell-code}\n        mean(mtcars$mpg, trim = 0.05)\n        ```\n        \n        ::: {.cell-output .cell-output-stdout}\n        \n        ```\n        [1] 19.95333\n        ```\n        \n        \n        :::\n        :::\n\n\n\n        -   `DescTools` package has a function `Trim()` that is an excerpt from the base function `mean()` but returns the trimmed data without calculating the mean:\n\n\n\n            ::: {.cell}\n            \n            ```{.r .cell-code}\n            library(DescTools)\n            mpg_ordered <- sort(mtcars$mpg)\n            Trim(mpg_ordered, 0.05)\n            ```\n            \n            ::: {.cell-output .cell-output-stdout}\n            \n            ```\n             [1] 10.4 13.3 14.3 14.7 15.0 15.2 15.2 15.5 15.8 16.4 17.3 17.8 18.1 18.7 19.2\n            [16] 19.2 19.7 21.0 21.0 21.4 21.4 21.5 22.8 22.8 24.4 26.0 27.3 30.4 30.4 32.4\n            attr(,\"trim\")\n            [1]  1 32\n            ```\n            \n            \n            :::\n            :::\n\n\n\n            -   The output shows the cleaned data after trimming $5\\%$ of the observations from each end and the location of the trimmed observations (the $1^{\\text{st}}$ and $32^{\\text{nd}}$ observations that were removed).\n\n            -   The percentage of trimming is multiplied by the number of observations to get the number of observations to be trimmed from each end (i.e., $0.05 \\times 32 = 1.6$ observations, which R rounds down to $1$).\n\n            -   Therefore, one observation has been removed from each end.\n\n-   $50\\%$ trimming is equivalent to the median:\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    mean(mtcars$mpg, trim = 0.5)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] 19.2\n    ```\n    \n    \n    :::\n    :::\n\n\n\n-   Discarding the extreme values leads to loss of information that can introduce bias in the estimation of the mean. Therefore, trimming should be used cautiously. It can be safely used to discard extreme values (outliers) that might be due to errors during measurement or data collection or when the extreme values are irrelevant to the rest of the data.\n\n### Winsorized mean\n\n-   The observations are arranged based on magnitude, then the extreme values beyond a certain percentile threshold are replaced by these threshold values.\n\n-   For example, $5\\%$ Winsorization involves replacing the values smaller than the $5^{th}$ percentile with the $5^{th}$ percentile value and the values larger than the $95^{th}$ percentile with the $95^{th}$ percentile value.\n\n-   The Winsorized mean $(\\bar{x}_W)$ is then calculated as the arithmetic mean of the modified observations.\n\n-   The Winsorized mean is less sensitive to outliers than the arithmetic mean.\n\n-   To Winsorize data, the `Winsorize()` function from the `DescTools` package can be used:\n\n    -   The function has `probs` argument that takes a vector of two values representing the lower and upper percentiles to be Winsorized (e.g., `probs = c(0.05, 0.95)` for $5\\%$ Winsorization).\n\n    -   In addition, there is `type` argument that specifies the algorithm to be used for calculating the perecentiles (discussed in details [here](/posts/biostats/B004_desc_stats.qmd)).\n\n    -   Example: the variable `mpg` in the `mtcars` dataset is $5\\%$ Winsorized as follows:\n\n        -   Calculate the $5^{th}$ and $95^{th}$ percentiles of the variable `mpg`:\n\n\n\n            ::: {.cell}\n            \n            ```{.r .cell-code}\n            quantile(\n            mtcars$mpg, \n            probs = c(0.05, 0.95),\n            type = 7\n            )\n            ```\n            \n            ::: {.cell-output .cell-output-stdout}\n            \n            ```\n                5%    95% \n            11.995 31.300 \n            ```\n            \n            \n            :::\n            :::\n\n\n\n        -   The `quantile()` function has been used to calculate the $5^{th}$ and $95^{th}$ percentiles of the variable `mpg`, which are $11.995$ and $31.3$, respectively. The `type` argument is set to $7$, which is the default algorithm for calculating the percentiles in R for continuous data.\n\n        -   Display the original values in order:\n\n\n\n            ::: {.cell}\n            \n            ```{.r .cell-code}\n            mpg_ordered\n            ```\n            \n            ::: {.cell-output .cell-output-stdout}\n            \n            ```\n             [1] 10.4 10.4 13.3 14.3 14.7 15.0 15.2 15.2 15.5 15.8 16.4 17.3 17.8 18.1 18.7\n            [16] 19.2 19.2 19.7 21.0 21.0 21.4 21.4 21.5 22.8 22.8 24.4 26.0 27.3 30.4 30.4\n            [31] 32.4 33.9\n            ```\n            \n            \n            :::\n            :::\n\n\n\n        -   Winsorize the variable `mpg` using the $5^{th}$ and $95^{th}$ percentiles:\n\n\n\n            ::: {.cell}\n            \n            ```{.r .cell-code}\n            mpg_win <- Winsorize(\n            x = mpg_ordered, \n            probs = c(0.05, .95),\n            type = 7\n            )\n                    \n            mpg_win\n            ```\n            \n            ::: {.cell-output .cell-output-stdout}\n            \n            ```\n             [1] 11.995 11.995 13.300 14.300 14.700 15.000 15.200 15.200 15.500 15.800\n            [11] 16.400 17.300 17.800 18.100 18.700 19.200 19.200 19.700 21.000 21.000\n            [21] 21.400 21.400 21.500 22.800 22.800 24.400 26.000 27.300 30.400 30.400\n            [31] 31.300 31.300\n            ```\n            \n            \n            :::\n            :::\n\n\n\n        -   The output of the `Winsorize()` function shows that the two smallest values $(10.4\\ \\text{and}\\ 10.4)$ that are smaller than the $5^{th}$ percentile $(11.995)$ have been replaced by the $5^{th}$ percentile. Whereas, the two largest values $32.4\\ \\text{and}\\ 33.9$ that are larger than the $95^{th}$ percentile $(31.3)$ have been replaced by the $95^{th}$ percentile.\n\n        -   Calculate the Winsorized mean of the variable `mpg`:\n\n\n\n            ::: {.cell}\n            \n            ```{.r .cell-code}\n            mean(mpg_win)\n            ```\n            \n            ::: {.cell-output .cell-output-stdout}\n            \n            ```\n            [1] 20.07469\n            ```\n            \n            \n            :::\n            :::\n\n\n\n        -   The Winsorized mean can be calculated directly using the function `winsor.mean()` function from the `psych` package:\n\n\n\n            ::: {.cell}\n            \n            ```{.r .cell-code}\n            library(psych)\n                    \n            winsor.mean(\n            mtcars$mpg, \n            trim = 0.05\n            )\n            ```\n            \n            ::: {.cell-output .cell-output-stdout}\n            \n            ```\n            [1] 20.07469\n            ```\n            \n            \n            :::\n            :::\n\n\n\n-   Unlike trimming, Winsorization preserves some of the original information in the data. The extreme values are not totally discarded but their weight (impact) is reduced.\n\n## References\n\n-   Daniel, W. W. and Cross, C. L. (2013). Biostatistics: A Foundation for Analysis in the Health Sciences, Tenth edition. Wiley\n\n-   Heumann, C., Schomaker, M., and Shalabh (2022). Introduction to Statistics and Data Analysis: With Exercises, Solutions and Applications in R. Springer\n\n-   Lane, D. M. et al., (2019). Introduction to Statistics. Online Edition. Retrieved September 14, 2024, from https://openstax.org/details/introduction-statistics\n\n<br>\n\n## Add your comments\n",
    "supporting": [
      "B003_desc_stats_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<link href=\"../../site_libs/htmltools-fill-0.5.8.1/fill.css\" rel=\"stylesheet\" />\n<script src=\"../../site_libs/htmlwidgets-1.6.4/htmlwidgets.js\"></script>\n<link href=\"../../site_libs/datatables-css-0.0.0/datatables-crosstalk.css\" rel=\"stylesheet\" />\n<script src=\"../../site_libs/datatables-binding-0.33/datatables.js\"></script>\n<script src=\"../../site_libs/jquery-3.6.0/jquery-3.6.0.min.js\"></script>\n<link href=\"../../site_libs/dt-core-1.13.6/css/jquery.dataTables.min.css\" rel=\"stylesheet\" />\n<link href=\"../../site_libs/dt-core-1.13.6/css/jquery.dataTables.extra.css\" rel=\"stylesheet\" />\n<script src=\"../../site_libs/dt-core-1.13.6/js/jquery.dataTables.min.js\"></script>\n<link href=\"../../site_libs/crosstalk-1.2.1/css/crosstalk.min.css\" rel=\"stylesheet\" />\n<script src=\"../../site_libs/crosstalk-1.2.1/js/crosstalk.min.js\"></script>\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}