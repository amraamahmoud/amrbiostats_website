{
  "hash": "7a1c8d43d1f050dcfb11c712448af121",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Frequency distribution 2\"\nsubtitle: \"Quantitative variables\"\nimage: \"/images/biostats.jpg\"\ndate: \"2024-10-05\"\nformat: \n  html: \n    fig-align: center\n    page-layout: article\n    toc: true\n    toc-depth: 5\n    toc-expand: true\n    lightbox: false\ncrossref: \n  custom: \n    - kind: float\n      reference-prefix: \"Example M.10.\"\n      key: tabset\n      space-before-numbering: false\neditor_options: \n  chunk_output_type: console\n---\n\n::: {.cell}\n\n:::\n\n\n\n\n## Frequency distribution of quantitative variables\n\n-   Quantitative variables have many unique values, which can lead to an extremely large number of categories.\n\n-   Therefore, these variables can be summarized by grouping the data into class intervals and counting the number of observations in each class interval.\n\n-   The class intervals are selected to be contiguous, non-overlapping, and exhaustive in a way that each observation can be assigned to one and only one class interval.\n\n-   Constructing few class intervals may result in loss of information, while constructing too many class intervals may not satisfy the purpose of summarizing the data.\n\n-   A rule of thumb is to have between 5 and 15 class intervals.\n\n-   There are different methods used as a guide to determine the number of class intervals, such as Sturges' rule, square root method, Freedman-Diaconis' rule, etc. For instance:\n\n    -   **Sturges' rule**: $k = 1 + 3.322 \\log_{10}(n)$, where $k$ is the number of class intervals and $n$ is the number of observations.\n\n-   Example: Consider the variable `mpg` (miles per gallon) in the `mtcars` dataset:\n\n    -   First, let's load the dataset and have a look at the variable:\n\n\n\n\n        ::: {.cell}\n        \n        ```{.r .cell-code}\n        # load the mtcars dataset\n        data(mtcars)\n        \n        # display the values of the mpg variable\n        mtcars$mpg\n        ```\n        \n        ::: {.cell-output .cell-output-stdout}\n        \n        ```\n         [1] 21.0 21.0 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 17.8 16.4 17.3 15.2 10.4\n        [16] 10.4 14.7 32.4 30.4 33.9 21.5 15.5 15.2 13.3 19.2 27.3 26.0 30.4 15.8 19.7\n        [31] 15.0 21.4\n        ```\n        \n        \n        :::\n        :::\n\n\n\n\n    -   The number of class intervals based on Sturges' rule can be calculated by either of the following methods:\n\n        ::: panel-tabset\n        ## Stepwise calculation\n\n\n\n\n        ::: {.cell}\n        \n        ```{.r .cell-code}\n        # determine the number of observations\n        n <- length(mtcars$mpg)\n        \n        # calculate the number of class intervals using Sturges' rule   \n        k <- 1 + 3.322 * log10(n)\n        paste0('The number of class intervals = ', round(k))\n        ```\n        \n        ::: {.cell-output .cell-output-stdout}\n        \n        ```\n        [1] \"The number of class intervals = 6\"\n        ```\n        \n        \n        :::\n        :::\n\n\n\n\n        ## Direct calculation\n\n\n\n\n        ::: {.cell}\n        \n        ```{.r .cell-code}\n        # use nclass.Sturges() function \n        k1  <- nclass.Sturges(mtcars$mpg)\n        paste0('The number of class intervals = ', round(k1))\n        ```\n        \n        ::: {.cell-output .cell-output-stdout}\n        \n        ```\n        [1] \"The number of class intervals = 6\"\n        ```\n        \n        \n        :::\n        :::\n\n\n\n        :::\n\n    -   The number of class intervals is 6 as suggested by Sturges' rule.\n\n        ::: {.callout-note style=\"color: #0466c8;\"}\n        -   These rules including Sturges' rule are not strict but rather provide guidance to determine the number of class intervals.\n\n        -   The actual number of class intervals can vary based on the researcher's judgment and the purpose of the analysis.\n        :::\n\n    -   Then, let's calculate the range, which is the difference between the maximum and minimum values of the variable:\n\n\n\n\n        ::: {.cell}\n        \n        ```{.r .cell-code}\n        # determine the minimum value of the mpg variable\n        min_mpg <- min(mtcars$mpg)\n        \n        # determine the maximum value of the mpg variable\n        max_mpg <- max(mtcars$mpg)\n        \n        # calculate the range of the mpg variable by subtracting the minimum from the maximum\n        r <- max_mpg - min_mpg\n        paste0('Range = ', r)\n        ```\n        \n        ::: {.cell-output .cell-output-stdout}\n        \n        ```\n        [1] \"Range = 23.5\"\n        ```\n        \n        \n        :::\n        :::\n\n\n\n        \n    -   R has a built-in function `range()` that returns the maximum and minimum values directly:\n\n\n\n        ::: {.cell}\n        \n        ```{.r .cell-code}\n        range(mtcars$mpg)\n        ```\n        \n        ::: {.cell-output .cell-output-stdout}\n        \n        ```\n        [1] 10.4 33.9\n        ```\n        \n        \n        :::\n        :::\n\n\n\n\n    -   The width of each class interval is approximately equal to $\\displaystyle \\frac {\\text{Range}}{k} = \\frac{23.5}{6} = 3.9 \\approx 4$.\n\n    -   As a rule of thumb, when appropriate, the width of the class interval is recommended to be of of 5 units, 10 units, or multiples of 10.\n\n    -   The first class interval should encompass the minimum (in this example $= 10.4$), while the last class interval should encompass the maximum (in this example $= 33.9$).\n\n    -   A good starting point would be $10$ and considering a width of $5$ units, the boundaries of the class intervals would be $10, 15, 20, 25, 30, \\text {and}\\ 35$.\n\n    -   Because each value should be assigned to one and only one class interval, the class intervals should be closed on one end and open on the other end, e.g., $[10, 15], (15, 20], (20, 25], (25, 30], (30, 35]$.\n\n        ::: {.callout-note style=\"color: #0466c8;\"}\n        -   The square bracket \\[ \\] denotes that the interval includes the corresponding lower or upper bound, while the parenthesis ( ) denotes that the interval excludes the corresponding lower or upper bound.\n\n        -   For instance, the second class interval $(15, 20]$ includes values greater than but not equal to $15$ and less than or equal to $20$ (i.e., $15 < x \\leq 20$).\n\n        -   This type is called exclusive-inclusive (also known as half-open, half-closed) interval.\n\n        -   The first class interval should have a closed lower bound to include the minimum value, if coincidentally the minimum value is equal to the lower bound of the first class interval.\n        :::\n\n    -   The class interval boundaries (i.e., breakpoints) can also be determined directly using the `pretty()` function in R:\n\n\n\n\n        ::: {.cell}\n        \n        ```{.r .cell-code}\n        bp <- pretty(mtcars$mpg)\n        paste0(\n           'The class interval breakpoints = ', \n           paste(bp, collapse = \", \")\n        )\n        ```\n        \n        ::: {.cell-output .cell-output-stdout}\n        \n        ```\n        [1] \"The class interval breakpoints = 10, 15, 20, 25, 30, 35\"\n        ```\n        \n        \n        :::\n        :::\n\n\n\n\n    -   We can use R to create a frequency distribution table for the `mpg` variable as follows:\n\n:::::: grid\n::: g-col-2\n:::\n\n::: g-col-8\n\n\n\n::: {#tbl-mpg-freq .cell tbl-cap='Frequency distribution of the mpg variable'}\n\n```{.r .cell-code}\nlibrary(DT)\n\n# create a vector to assign each value to a class interval\nmpg_class <-\n  cut(\n    mtcars$mpg,\n    breaks = seq(10, 35, by = 5),\n    include.lowest = TRUE,\n    right = TRUE\n  )\n\n# include.lowest = TRUE ensures that the minimum value is included in the first class interval or the maximum value is included in the last class interval if right argument is set to FALSE.\n\n# right = TRUE ensures that the intervals are left-open and right-closed.\n\n# create a frequency distribution table for the mpg variable\nfreq_tbl_1 <- table(mpg_class)\n\n# create a data frame from the frequency table\nfreq_tbl_df_1 <- data.frame(freq_tbl_1)\n\n# convert the mpg_class column to character\nfreq_tbl_df_1$mpg_class <- as.character(freq_tbl_df_1$mpg_class)\n\n# add a row for the total frequency\nfreq_tbl_df_1 <-\n  rbind(\n    freq_tbl_df_1, \n    c(\"Total\", \n      sum(freq_tbl_df_1$Freq)\n     )\n  )\n\n# display the frequency distribution table (optional)\ndatatable(\n  freq_tbl_df_1,\n  colnames = c(\n    \"Class Interval\" = \"mpg_class\",\n    \"Frequency\" = \"Freq\"\n  ),\n  options = list(\n    dom = \"t\",\n    columnDefs = list(\n      list(\n        className = \"dt-center\",\n        targets = \"_all\"\n      )\n    )\n  ),\n  rownames = FALSE\n)\n```\n\n::: {.cell-output-display}\n\n```{=html}\n<div class=\"datatables html-widget html-fill-item\" id=\"htmlwidget-30969f252377918d8a68\" style=\"width:100%;height:auto;\"></div>\n<script type=\"application/json\" data-for=\"htmlwidget-30969f252377918d8a68\">{\"x\":{\"filter\":\"none\",\"vertical\":false,\"data\":[[\"[10,15]\",\"(15,20]\",\"(20,25]\",\"(25,30]\",\"(30,35]\",\"Total\"],[\"6\",\"12\",\"8\",\"2\",\"4\",\"32\"]],\"container\":\"<table class=\\\"display\\\">\\n  <thead>\\n    <tr>\\n      <th>Class Interval<\\/th>\\n      <th>Frequency<\\/th>\\n    <\\/tr>\\n  <\\/thead>\\n<\\/table>\",\"options\":{\"dom\":\"t\",\"columnDefs\":[{\"className\":\"dt-center\",\"targets\":\"_all\"},{\"name\":\"mpg_class\",\"targets\":0},{\"name\":\"Freq\",\"targets\":1}],\"order\":[],\"autoWidth\":false,\"orderClasses\":false}},\"evals\":[],\"jsHooks\":[]}</script>\n```\n\n:::\n:::\n\n\n\n:::\n\n::: g-col-2\n:::\n::::::\n\n### Relative and cumulative frequencies\n\n-   **Relative frequency of a class interval**:\n\n    -   It is the proportion of observations that fall within that class interval relative to the total number of observations.\n\n    -   It is simply calculated by dividing the frequency of that class interval by the total number of observations.\n\n-   **Cumulative frequency**:\n\n    -   As the name implies, it is the frequency of values falling within two or more class intervals.\n\n    -   At each class interval, we calculate the sum of the frequency of that class interval and all previous class intervals.\n\n-   **Cumulative relative frequency**:\n\n    -   It is calculated by dividing the cumulative frequency by the total number of observations.\n\n::: {.callout-note style=\"color: #0466c8;\"}\n-   The relative frequency, cumulative frequency, and cumulative relative frequency are calculated for categorical variables in the same way as for numerical variables.\n:::\n\n-   The relative frequency, cumulative frequency, and cumulative relative frequency of the `mpg` variable can be calculated as follows:\n\n    -   The relative frequencies:\n\n\n\n\n        ::: {.cell}\n        \n        ```{.r .cell-code}\n        # calculate the relative frequency\n        rel_freq_1 <- prop.table(freq_tbl_1)\n        rel_freq_1\n        ```\n        \n        ::: {.cell-output .cell-output-stdout}\n        \n        ```\n        mpg_class\n        [10,15] (15,20] (20,25] (25,30] (30,35] \n         0.1875  0.3750  0.2500  0.0625  0.1250 \n        ```\n        \n        \n        :::\n        :::\n\n\n\n\n    -   The cumulative frequencies:\n\n\n\n\n        ::: {.cell}\n        \n        ```{.r .cell-code}\n        # calculate the cumulative frequency\n        cum_freq_1 <- cumsum(freq_tbl_1)\n        cum_freq_1\n        ```\n        \n        ::: {.cell-output .cell-output-stdout}\n        \n        ```\n        [10,15] (15,20] (20,25] (25,30] (30,35] \n              6      18      26      28      32 \n        ```\n        \n        \n        :::\n        :::\n\n\n\n\n    -   The cumulative relative frequencies:\n\n\n\n\n        ::: {.cell}\n        \n        ```{.r .cell-code}\n        # calculate the cumulative relative frequency\n        cum_rel_freq_1 <- cumsum(rel_freq_1)\n        cum_rel_freq_1\n        ```\n        \n        ::: {.cell-output .cell-output-stdout}\n        \n        ```\n        [10,15] (15,20] (20,25] (25,30] (30,35] \n         0.1875  0.5625  0.8125  0.8750  1.0000 \n        ```\n        \n        \n        :::\n        :::\n\n\n\n\n    -   The frequency distribution table with relative and cumulative frequencies can be displayed collectively as follows:\n\n\n\n\n        ::: {#tbl-mpg-cum-freq .cell tbl-cap='Cumulative frequency distribution of the mpg variable'}\n        \n        ```{.r .cell-code}\n        # create a data frame from the cumulative frequency table\n        cum_freq_df_1 <-\n          data.frame(\n            freq_tbl_1, \n            cum_freq_1 = as.numeric(cum_freq_1),\n            rel_freq_1 = as.numeric(rel_freq_1),\n            cum_rel_freq_1 = as.numeric(cum_rel_freq_1)\n          )\n        \n        # convert the mpg_class column to character\n        cum_freq_df_1$mpg_class <- as.character(cum_freq_df_1$mpg_class)\n        \n        # add a row for the total frequency\n        cum_freq_df_1 <-\n            rbind(\n               cum_freq_df_1,\n               c(\n                 \"Total\",\n                 sum(cum_freq_df_1$Freq),\n                 NA,\n                 sum(cum_freq_df_1$rel_freq),\n                 NA\n               )\n            )  \n            \n        # display the cumulative frequency distribution table\n        datatable(\n            cum_freq_df_1,\n            colnames = c(\n              \"Class Interval\" = \"mpg_class\", \n              \"Frequency\" = \"Freq\",\n              \"Cumulative Frequency\" = \"cum_freq_1\",\n              \"Relative Frequency\" = \"rel_freq_1\",\n              \"Cumulative Relative Frequency\" = \"cum_rel_freq_1\"\n            ),\n            options = list(\n              dom = \"t\", \n              columnDefs = list(\n                list(\n                className = \"dt-center\", \n                targets = \"_all\"          \n                )\n              )\n            ),\n          rownames = FALSE\n        ) %>% \n        formatRound(\n          columns = c(4, 5), \n          digits = 5\n        ) %>%\n        formatStyle(\n          columns = c(1:5),\n          backgroundColor = styleRow(\n            3,\n            \"lightgreen\"\n          ) \n        ) %>%\n        formatStyle(\n          columns = c(4:5),\n          backgroundColor = styleEqual(\n            1,\n            c(\"skyblue\")\n          )\n        )\n        ```\n        \n        ::: {.cell-output-display}\n        \n        ```{=html}\n        <div class=\"datatables html-widget html-fill-item\" id=\"htmlwidget-901ab9817e183e7dc7b9\" style=\"width:100%;height:auto;\"></div>\n        <script type=\"application/json\" data-for=\"htmlwidget-901ab9817e183e7dc7b9\">{\"x\":{\"filter\":\"none\",\"vertical\":false,\"data\":[[\"[10,15]\",\"(15,20]\",\"(20,25]\",\"(25,30]\",\"(30,35]\",\"Total\"],[\"6\",\"12\",\"8\",\"2\",\"4\",\"32\"],[\"6\",\"18\",\"26\",\"28\",\"32\",null],[\"0.1875\",\"0.375\",\"0.25\",\"0.0625\",\"0.125\",\"1\"],[\"0.1875\",\"0.5625\",\"0.8125\",\"0.875\",\"1\",null]],\"container\":\"<table class=\\\"display\\\">\\n  <thead>\\n    <tr>\\n      <th>Class Interval<\\/th>\\n      <th>Frequency<\\/th>\\n      <th>Cumulative Frequency<\\/th>\\n      <th>Relative Frequency<\\/th>\\n      <th>Cumulative Relative Frequency<\\/th>\\n    <\\/tr>\\n  <\\/thead>\\n<\\/table>\",\"options\":{\"dom\":\"t\",\"columnDefs\":[{\"targets\":3,\"render\":\"function(data, type, row, meta) {\\n    return type !== 'display' ? data : DTWidget.formatRound(data, 5, 3, \\\",\\\", \\\".\\\", null);\\n  }\"},{\"targets\":4,\"render\":\"function(data, type, row, meta) {\\n    return type !== 'display' ? data : DTWidget.formatRound(data, 5, 3, \\\",\\\", \\\".\\\", null);\\n  }\"},{\"className\":\"dt-center\",\"targets\":\"_all\"},{\"name\":\"mpg_class\",\"targets\":0},{\"name\":\"Freq\",\"targets\":1},{\"name\":\"cum_freq_1\",\"targets\":2},{\"name\":\"rel_freq_1\",\"targets\":3},{\"name\":\"cum_rel_freq_1\",\"targets\":4}],\"order\":[],\"autoWidth\":false,\"orderClasses\":false,\"rowCallback\":\"function(row, data, displayNum, displayIndex, dataIndex) {\\nvar value=data[0]; $(this.api().cell(row, 0).node()).css({'background-color':$.inArray(dataIndex + 1, [3]) >= 0 ? \\\"lightgreen\\\" : null});\\nvar value=data[1]; $(this.api().cell(row, 1).node()).css({'background-color':$.inArray(dataIndex + 1, [3]) >= 0 ? \\\"lightgreen\\\" : null});\\nvar value=data[2]; $(this.api().cell(row, 2).node()).css({'background-color':$.inArray(dataIndex + 1, [3]) >= 0 ? \\\"lightgreen\\\" : null});\\nvar value=data[3]; $(this.api().cell(row, 3).node()).css({'background-color':$.inArray(dataIndex + 1, [3]) >= 0 ? \\\"lightgreen\\\" : null});\\nvar value=data[4]; $(this.api().cell(row, 4).node()).css({'background-color':$.inArray(dataIndex + 1, [3]) >= 0 ? \\\"lightgreen\\\" : null});\\nvar value=data[3]; $(this.api().cell(row, 3).node()).css({'background-color':value == 1 ? \\\"skyblue\\\" : null});\\nvar value=data[4]; $(this.api().cell(row, 4).node()).css({'background-color':value == 1 ? \\\"skyblue\\\" : null});\\n}\"}},\"evals\":[\"options.columnDefs.0.render\",\"options.columnDefs.1.render\",\"options.rowCallback\"],\"jsHooks\":[]}</script>\n        ```\n        \n        :::\n        :::\n\n\n\n\n-   As you can see from @tbl-mpg-cum-freq:\n\n    -   The relative frequency of the class interval $(20, 25] = \\displaystyle \\frac{8}{32} = 0.25$.\n\n    -   The cumulative frequency at the class interval $(20, 25] = 6 + 12 + 8 = 26$, which represents the number of observations that fall within the wider class interval $[10, 25]$ that incorporates the class intervals $[10, 15]$, $(15, 20]$, and $(20, 25]$.\n\n    -   The cumulative relative frequency at the class interval $(20, 25] = \\displaystyle \\frac{6}{32} + \\frac{12}{32} + \\frac{8}{32} = \\frac{26}{32} = 0.8125$.\n\n    -   Notice:\n\n        -   The relative frequencies should sum up to 1.\n\n        -   The cumulative relative frequency at the last class interval should be 1.\n\n-   The above frequency distribution table can constructed directly using `freq()` function from the `summarytools` package as follows:\n\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    library(summarytools)\n    library(DT)\n    \n    datatable(\n      freq(\n        cut(\n          mtcars$mpg, \n          breaks = pretty(mtcars$mpg), \n          include.lowest = T, \n          right = T\n        )\n      ),   \n      options = list(\n        dom = \"t\",\n        columnDefs = list(\n          list(\n            className = \"dt-center\", \n            targets = \"_all\"\n          )\n        )\n     )\n       )\n    ```\n    \n    ::: {.cell-output-display}\n    \n    ```{=html}\n    <div class=\"datatables html-widget html-fill-item\" id=\"htmlwidget-852717964f91cf210e54\" style=\"width:100%;height:auto;\"></div>\n    <script type=\"application/json\" data-for=\"htmlwidget-852717964f91cf210e54\">{\"x\":{\"filter\":\"none\",\"vertical\":false,\"data\":[[\"[10,15]\",\"(15,20]\",\"(20,25]\",\"(25,30]\",\"(30,35]\",\"&lt;NA&gt;\",\"Total\"],[6,12,8,2,4,0,32],[18.75,37.5,25,6.25,12.5,null,100],[18.75,56.25,81.25,87.5,100,null,100],[18.75,37.5,25,6.25,12.5,0,100],[18.75,56.25,81.25,87.5,100,100,100]],\"container\":\"<table class=\\\"display\\\">\\n  <thead>\\n    <tr>\\n      <th> <\\/th>\\n      <th>Freq<\\/th>\\n      <th>% Valid<\\/th>\\n      <th>% Valid Cum.<\\/th>\\n      <th>% Total<\\/th>\\n      <th>% Total Cum.<\\/th>\\n    <\\/tr>\\n  <\\/thead>\\n<\\/table>\",\"options\":{\"dom\":\"t\",\"columnDefs\":[{\"className\":\"dt-center\",\"targets\":\"_all\"},{\"orderable\":false,\"targets\":0},{\"name\":\" \",\"targets\":0},{\"name\":\"Freq\",\"targets\":1},{\"name\":\"% Valid\",\"targets\":2},{\"name\":\"% Valid Cum.\",\"targets\":3},{\"name\":\"% Total\",\"targets\":4},{\"name\":\"% Total Cum.\",\"targets\":5}],\"order\":[],\"autoWidth\":false,\"orderClasses\":false}},\"evals\":[],\"jsHooks\":[]}</script>\n    ```\n    \n    :::\n    :::\n\n\n\n\n### Graphical representation\n\n#### Stem and leaf plot\n\n-   It is a graphical way to display the distribution of quantitative variables.\n\n-   It can be used when the number of observations is not too large.\n\n-   It is similar to the histogram (will be discussed shortly) but retains the original data values.\n\n-   The stem-and-leaf plot is constructed by dividing each observation into two parts, the stem and the leaf separated by a vertical line $(|)$.\n\n-   Stem:\n\n    -   The stem is the leftmost digit(s) of the observation.\n\n    -   Form a column to the left of the vertical line arranged in ascending order from top to bottom.\n\n-   Leaf:\n\n    -   The leaf is the rightmost digit(s) of the observation.\n\n    -   They are ordered and placed to the right of the vertical line with the corresponding stem.\n\n-   Even though R has a bulit in function to create stem-and-leaf plots, the `stem.leaf()` function from the `aplpack` package provides more informative output and is more flexible with regard to customization:\n\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    library(aplpack)\n    \n    stem.leaf(\n    mtcars$mpg,\n    style = \"bare\", \n    m = 2  # number of parts (rows) to which the stem is divided\n    )\n    ```\n    :::\n\n\n\n\n![](/images/stem_leaf.png)\n\n-   The above output can be interpreted as follows:\n\n    1.  This header indicates that stem should be interpreted as tens (or hundreds, etc), whereas leaf should be interpreted as ones not as tenth decimal place (i.e., interpret $1\\ |\\ 2$ as $12$ not $1.2$). This can be controlled using the argument `unit`, which accepts numbers as power of 10 (e.g., 2, 1, 0.1, 0.01, etc).\n\n    2.  This shows that the leaf unit is 1 (i.e., the leaf represents the ones place).\n\n    3.  This shows the ntotal number of observations.\n\n    4.  This column shows the stem values (i.e., the tens place); Each stem is separated into two parts (rows), the first contains leaves from 0 to 4, and the second contains leaves from 5 to 9.\n\n    5.  This shows the leaves (i.e., the ones place) corresponding to the stem values.\n\n    6.  This column is referred to as the `depths`, which shows the accumulated frequencies from the top and bottom of the plot until reaching the row that contains the middle value (i.e., the median). So, the last $(5^{\\text{th}})$ row has depth of $4$ because there are $4$ observations (leaves) with stem value $3$. The second row from the bottom $(4^{\\text{th}})$ has a depth of $6$ because there are $4$ leaves in the $5^{\\text{th}}$ row and $2$ leaves in the $4^{\\text{th}}$ row.\n\n    7.  This shows the row containing the middle value (i.e., the median). The frequency of leaves in this row is placed in parentheses to indicate that the median is in this row. For example, the median of the `mpg` variable is $19.2$, which is in the $2^{\\text{nd}}$ row that contains $13$ leaves.\n\n    ::: {.callout-note style=\"color: #0466c8;\"}\n    -   In the above example, the decimals have been omitted from the leaves because the `unit` argument is set to 1 (i.e., the leaves represent the ones place).\n\n    -   Sometimes, a plus $(+)$ is added at the end of one or more rows to indicate that the leaves exceed the row capacity, and thus, the leaves are not shown in the plot.\n    :::\n\n#### Histogram\n\n-   It is used to graphically represent the distribution of values of quantitative variables, particularly when there are a large number of observations.\n\n-   It can be used to get insights about the underlying shape of the distribution that generated the data based on the sample.\n\n-   The class intervals are represented on the horizontal axis, whereas the vertical axis represents the frequency of the values or the relative frequency `density` scale.\n\n-   Each class interval on the horizontal axis has a rectangular vertical bar.\n\n-   If the vertical axis scale is the `frequency`, the height $(h_i)$ of the bar corresponds to the frequency $(n_i)$ of that class interval (i.e., $h_i = n_i$).\n\n-   If the vertical axis scale is the `density`, the height of the bar corresponds to relative frequency $\\left ( f_i = \\displaystyle \\frac{n_i}{\\sum n_i} \\right)$ of that class interval divided by the width $(d_i)$ of the class interval (i.e., $h_i = \\displaystyle \\frac{f_i}{d_i}$):\n\n    -   Therefore, the area of each bar $= \\text {height} \\times \\text {width} = \\displaystyle \\frac{f_i}{\\cancel{d_i}} \\times \\cancel{d}_i = f_i$ (i.e., the relative frequency).\n\n    -   In this context, the bars can have different widths because the area of each bar is proportional to the relative frequency (however, usually the bars have equal width).\n\n-   The bars are contiguous, non-overlapping, and possess no gaps.\n\n-   The histogram of the `mpg` variable can be created as follows:\n\n    ::: panel-tabset\n    ## Base R\n\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    # adjust the plot layout to display two plots side by side\n    par(mfrow=c(1,2))\n    \n    # create a histogram based on frequency\n    hist(\n      x = mtcars$mpg,\n      main = \"Histogram based \\n on frequency\",   # \\n is used to create a new line\n      xlab = \"Miles per Gallon (MPG)\",\n      ylab = \"Frequency\",\n      col = \"skyblue\",\n      border = \"black\",\n      ylim = c(0, 14),\n    )\n    \n    # The breaks were determined automatically but it can be changed using the breaks  argument\n    \n    # hist() uses left-open and right-closed intervals by default.\n    \n    \n    # create a histogram based on relative frequency\n    hist(\n     mtcars$mpg,\n     prob = TRUE, # this is equivalent to freq = FALSE\n     main = \"Histogram based on \\n relative frequency\",\n     xlab = \"Miles per Gallon (MPG)\",\n     ylab = \"Density\",\n     col = \"skyblue\",\n     border = \"black\",\n     ylim = c(0, 0.08),\n    )\n    ```\n    \n    ::: {.cell-output-display}\n    ![](B002_Freq_dist2_ss_files/figure-html/unnamed-chunk-15-1.png){width=672}\n    :::\n    :::\n\n\n\n\n    ## Using `ggplot2`\n\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    library(ggplot2)\n    \n    # create a histogram based on frequency\n    \n    h1 <- \n     ggplot(\n       mtcars, \n       aes(x = mpg)\n     ) + # aes() needs x argument only\n     geom_histogram(\n       fill = \"skyblue\",\n       color = \"black\"\n     ) +\n     labs(\n       title = \"Histogram based on frequency\",\n       x = \"Miles per Gallon (MPG)\",\n       y = \"Frequency\"\n     ) +\n     theme_bw()\n    \n     h1\n    ```\n    \n    ::: {.cell-output-display}\n    ![](B002_Freq_dist2_ss_files/figure-html/unnamed-chunk-16-1.png){width=672}\n    :::\n    :::\n\n\n\n\n    -   The histogram is different from the base R histogram because `ggplot()` uses 30 bins (bars) by default, which might not be appropriate all the time.\n\n    -   This can be changed by modifying the `bins` argument in `geom_histogram()`.\n\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    h2 <-\n      ggplot(mtcars, aes(x = mpg)) + \n      geom_histogram(\n        fill = \"skyblue\",\n        color = \"black\",\n        bins = 5\n      ) +\n      labs(\n        title = \"Histogram based on frequency\",\n        x = \"Miles per Gallon (MPG)\",\n        y = \"Frequency\"\n      ) +\n      theme_bw()\n    \n     h2\n    ```\n    \n    ::: {.cell-output-display}\n    ![](B002_Freq_dist2_ss_files/figure-html/unnamed-chunk-17-1.png){width=672}\n    :::\n    :::\n\n\n\n\n    -   Now, we have 5 bins like the histogram created by base R, however, the ticks on the $x$-axis and bin width are different.\n\n    -   We can check the breaks created by `ggplot()` using the following code:\n\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    ggplot_build(h2)$data[[1]]$xmin\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1]  8.8125 14.6875 20.5625 26.4375 32.3125\n    ```\n    \n    \n    :::\n    :::\n\n\n\n\n    -   To get the same breaks as in the base R histogram, we can adjust the arguments `binwidth`, `boundary`, and `closed` in the `geom_histogram()` as follows\n\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    h3 <-\n      ggplot(mtcars, aes(x = mpg)) + \n      geom_histogram(\n        fill = \"skyblue\",\n        color = \"black\", \n        binwidth = 5, \n        boundary = 0,\n        closed = \"right\"\n      ) +\n      labs(\n        title = \"Histogram based on frequency\",\n        x = \"Miles per Gallon (MPG)\",\n        y = \"Frequency\"\n      ) +\n      scale_y_continuous(\n        breaks = seq(0, 14, by = 2),\n        limits = c(0, 14),\n        expand = c(0, 0)\n      ) +\n      theme_bw() +\n      theme(\n        plot.title = element_text(hjust = 0.5)\n      )\n    h3\n    ```\n    \n    ::: {.cell-output-display}\n    ![](B002_Freq_dist2_ss_files/figure-html/unnamed-chunk-19-1.png){width=672}\n    :::\n    :::\n\n\n\n\n    -   The histogram based on relative frequency can be created as follows:\n\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    # histogram based on relative frequency using after_stat(density) as argument insides aes() \n    h4 <- \n      ggplot(mtcars, aes(x = mpg, after_stat(density))) + \n      geom_histogram(\n        fill = \"skyblue\",\n        color = \"black\", \n        binwidth = 5, \n        boundary = 0, \n        closed = \"right\", \n      ) +\n      labs(\n        title = \"Histogram based on \\n relative frequency\",\n        x = \"Miles per Gallon (MPG)\",\n        y = \"Desnsity\"\n      ) +\n      scale_y_continuous(\n        limits = c(0, 0.08),\n        expand = c(0, 0)\n      ) +\n      theme_bw() +\n      theme(\n        plot.title = element_text(hjust = 0.5)\n      )\n    h4\n    ```\n    \n    ::: {.cell-output-display}\n    ![](B002_Freq_dist2_ss_files/figure-html/unnamed-chunk-20-1.png){width=672}\n    :::\n    :::\n\n\n\n\n    -   Display both histograms side by side:\n\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    library(patchwork)\n    ```\n    \n    ::: {.cell-output .cell-output-stderr}\n    \n    ```\n    Warning: package 'patchwork' was built under R version 4.4.1\n    ```\n    \n    \n    :::\n    \n    ```{.r .cell-code}\n    h3 + h4\n    ```\n    \n    ::: {.cell-output-display}\n    ![](B002_Freq_dist2_ss_files/figure-html/unnamed-chunk-21-1.png){width=672}\n    :::\n    :::\n\n\n\n    :::\n\n#### Kernel density plot\n\n-   The histogram has a disadvantage in that the shape of the distribution is influenced by the choice of the number of class intervals (i.e., bins). Different bin sizes can give a different impression of the underlying distribution.\n\n-   This problem can be addressed by using the kernel density plot, which is a smoothed version of the histogram and less sensitive to the choice of the number of bins:\n\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](B002_Freq_dist2_ss_files/figure-html/unnamed-chunk-22-1.png){width=672}\n:::\n:::\n\n\n\n\n-   Using the kernel density plot, the shape of the distribution is represented by a continuous function (i.e., curve) estimated from the sample data.\n\n-   Like histograms, the density plots give insights about the underlying shape of the distribution that generated the data based on the sample.\n\n-   In simple words, the kernel density estimation (KDE) is based on the idea that the more data points are clustered together, the higher is the probability density in that region (i.e., the higher is the probability of an observation falling in that region):\n\n    -   KDE places a small kernel (bump) centered at each data point.\n\n    -   The density of the bump is highest at the data points and decreases by moving away from the data points.\n\n    -   The small kernels (bumps) are summed to estimate the overall density at each point.\n\n-   Assume the following set of data: $5, 6, 7, 8, 11, 12$:\n\n\n\n\n    ::: {.cell}\n    ::: {.cell-output-display}\n    ![](B002_Freq_dist2_ss_files/figure-html/unnamed-chunk-23-1.png){width=672}\n    :::\n    :::\n\n\n\n\n    -   In the above density plot:\n\n        -   The dashed blue lines represent the small bumps (kernel functions) centered at each data point.\n\n        -   The solid red line represents the overall kernel density estimate.\n\n        -   The green tickmarks at the bottom of the plot represent the data points.\n\n    -   The small bumps are summed to estimate the overall density.\n\n    -   The overall desnsity is highest between 5 and 8 because more data points are clustered in that region.\n\n-   The kernel function used for the estimation is given by:\n\n$$\n\\displaystyle \\hat f_n(x) = \\frac{1}{nh} \\sum_{i=1}^{n} K \\left( \\frac{x - x_i}{h} \\right)\n$$\n\n::: {style=\"margin-left: 50px; color: #0466c8;\"}\n-   $\\hat f_n(x)$ is the kernel density estimate at $x$\n\n-   $n$ is the number of observations\n\n-   $h$ is the bandwidth, $h > 0$\n\n-   $\\displaystyle K \\left( \\frac{x - x_i}{h} \\right)$ is the kernel function (mentioned below as $K(u)$, where $u = \\displaystyle \\frac{x - x_i}{h}$)\n\n-   $x_i$ is the $i^{\\text{th}}$ observation of the data\n:::\n\n-   There are different kernel functions, such as the Gaussian kernel, Epanechnikov kernel, rectangular kernel, etc:\n\n    | Kernel Function | Formula |\n    |------------------------------------|:----------------------------------:|\n    | Gaussian (default in R) | $$\n    K(u) = \\displaystyle \\frac{1}{\\sqrt{2\\pi}} e^{-\\large \\frac{u^2}{2}}\n    $$ |\n    | Epanechnikov | $$\n        K(u) =\n        \\begin{cases} \n        \\displaystyle \\frac{3}{4}(1 - u^2) &  \\quad \\text{if}\\ |u| \\lt 1 \\\\ \\\\\n        0 & \\quad \\text{otherwise}\n        \\end{cases}\n    $$ |\n    | Rectangular | $$\n        K(u) =\n        \\begin{cases} \n        \\displaystyle \\frac{1}{2} &  \\quad \\text{if}\\ -1 \\le u \\le 1 \\\\ \\\\\n        0 & \\quad \\text{otherwise}\n        \\end{cases}\n    $$ |\n\n-   Characteristics of the kernel function:\n\n    -   The kernel function is symmetric around zero.\n\n    -   The kernel function integrates to one (this makes the kernel density estimator a probability density function, a concept tha will be discussed in upcoming tutorials).\n\n-   The kernel density plot for the `mpg` variable can be created in R as follows :\n\n    ::: panel-tabset\n    ## Base R\n\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    # create a kernel density plot using the default Gaussian kernel\n    plot(\n      density(\n        mtcars$mpg\n      ),\n      main = \"Kernel density plot\",\n      xlab = \"Miles per Gallon (MPG)\",\n      ylab = \"Density\",\n      col = \"#0466c8\",\n      lwd = 2, \n      ylim = c(0, 0.08)\n    )\n    \n    # add a kernel density plot using the Epanechnikov kernel \n    lines(\n      density(\n        mtcars$mpg,\n        kernel = \"epanechnikov\",\n      ),\n      col = \"#e63946\",\n      lty = \"dashed\", \n      lwd = 1.5\n    )\n    \n    # add a legend\n    legend(\n      \"topleft\",\n      legend = c(\"Gaussian\", \"Epanechnikov\"),\n      col = c(\"#0466c8\", \"#e63946\"),\n      lty = c(\"solid\", \"dashed\"),\n      lwd = c(2, 1.5)\n    )\n    ```\n    \n    ::: {.cell-output-display}\n    ![](B002_Freq_dist2_ss_files/figure-html/unnamed-chunk-24-1.png){width=672}\n    :::\n    :::\n\n\n\n\n    ## Using `ggplot2`\n\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    library(ggplot2)\n    # create a kernel density plot using the default Gaussian kernel\n    ggplot(\n      data = mtcars, \n      aes(x = mpg)\n    ) +  # ggplot() accepts only a data frame\n    stat_density(\n      aes(color = \"Gaussian\"),  # Label used in the legend \n      kernel = \"gaussian\",  # default kernel\n      geom = \"line\",\n    ) +\n    stat_density(\n      aes(color = \"Epanechnikov\"),  # Label used in the legend\n      kernel = \"epanechnikov\",\n      linetype = \"dashed\",\n      geom = \"line\",\n    ) + \n    labs(\n      title = \"Kernel density plot\",\n      x = \"Miles per Gallon (MPG)\",\n      y = \"Density\", \n      color = \"Kernel\"  # title of legend\n    ) +\n    scale_color_manual(\n      values = c(\n        \"Gaussian\" = \"#0466c8\", \n        \"Epanechnikov\" = \"#ba181b\"\n      ) \n    ) +\n    xlim(2, 40) +\n    theme_bw()\n    ```\n    \n    ::: {.cell-output-display}\n    ![](B002_Freq_dist2_ss_files/figure-html/unnamed-chunk-25-1.png){width=672}\n    :::\n    :::\n\n\n\n\n    :::\n\n-   The shape of kernel density plot is affected by the choice of the $h$ `(bandwidth)` parameter, which controls the smoothness of the curve:\n\n    -   When $h$ is too small, the curve becomes wiggly (i.e., undersmoothed) because the bandwidth is too narrow to smooth out random fluctuations in the data (i.e., the density estimate captures noise rather than the true underlying distribution).\n\n    -   When $h$ is too large, the curve becomes oversmoothed because the wide bandwidth smooths out (i.e., combines) more bumps leading to a density estimate that fails to capture the true underlying distribution.\n\n    -   The bandwidth can be controlled using the `bw` argument in both `density()` and `stat_density()` functions.\n\n    -   This can be illustrated by the following figure:\n\n\n\n\n        ::: {.cell}\n        \n        ```{.r .cell-code}\n        # plot density with default bandwidth \n        plot(\n          density(\n          mtcars$mpg\n          ),\n          main = \"Kernel density plot with different bandwidths\",\n          xlab = \"Miles per Gallon (MPG)\",\n          ylab = \"Density\",\n          col = \"#0466c8\",\n          lwd = 2, \n          ylim = c(0, 0.1)\n        )\n        \n        # add a kernel density plot with a smaller bandwidth\n        lines(\n          density(\n          mtcars$mpg,\n          bw = 1\n          ),\n          col = \"#e63946\",\n          lwd = 2\n        )\n        \n        # add a kernel density plot with a larger bandwidth\n        lines(\n          density(\n          mtcars$mpg,\n          bw = 6\n          ),\n          col = \"#38b000\",\n          lwd = 2\n        )\n        \n        # add a legend\n        legend(\n          \"topleft\",\n          legend = c(\"h=default\", \"h=0.5\", \"h=3\"),\n          col = c(\"#0466c8\", \"#e63946\", \"#38b000\"),\n          lwd = c(2, 2, 2)\n        )\n        ```\n        \n        ::: {.cell-output-display}\n        ![](B002_Freq_dist2_ss_files/figure-html/unnamed-chunk-26-1.png){width=672}\n        :::\n        :::\n\n\n\n\n::: {.callout-note style=\"color: #0466c8;\"}\n-   R uses its own algorithm to estimate the density, the following is quoted from the `density()` function documentation:\n\n    -   \"The algorithm used in density.default disperses the mass of the empirical distribution function over a regular grid of at least 512 points and then uses the fast Fourier transform to convolve this approximation with a discretized version of the kernel and then uses linear approximation to evaluate the density at the specified points.\"\n\n    -   By default, R calculates the bandwidth using Silverman's rule of thumb:\n\n        -   $\\displaystyle h = 0.9 \\times \\text{min} \\left( \\hat \\sigma, \\frac{\\text{IQR}}{1.34} \\right) \\times n^{-\\large \\frac{1}{5}}$\n\n        -   where $\\hat \\sigma$ is the standard deviation estimated from the sample, $\\text{IQR}$ is the interquartile range, and $n$ is the number of observations.\n\n        -   The bandwidth `(bw)` is then multiplied by `adjust` (default is 1) to get the final bandwidth.\n\n        -   Therefore, modifying the `adjust` argument can change the bandwidth, e.g., if `adjust` is set to 0.5, the bandwidth is halved.\n\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](B002_Freq_dist2_ss_files/figure-html/unnamed-chunk-27-1.png){width=672}\n:::\n:::\n\n\n\n:::\n\n### The shape of the distribution\n\n-   Histograms and density plots can be used to reveal the distribution of the data.\n\n-   The shape of the distribution can be symmetric, skewed to the right, or skewed to the left:\n\n    -   Symmetric distribution has a mirror image on both sides of the center.\n\n    -   Right-skewed (positively-skewed) distribution has a long tail to the right (caused by a few large values).\n\n    -   Left-skewed (negatively-skewed) distribution has a long tail to the left (caused by a few small values).\n    \n\n-   Example of symmetric, right-skewed, and left-skewed distributions are presented below:\n\n\n\n\n    ::: {.cell}\n    ::: {.cell-output-display}\n    ![](B002_Freq_dist2_ss_files/figure-html/unnamed-chunk-28-1.png){width=672}\n    :::\n    :::\n\n\n\n\n- There are other types of graphical representations that can be used to display the distribution of data, such as box plots, violin plots, and quantile-quantile plots, which will be discussed in upcoming tutorials.\n\n\n\n::: panel-tabset\n## [Exercise B.2.1 {{< iconify fluent:chat-bubbles-question-20-filled size=21px >}}]{style=\"color: #ba181b\"}\n\n-   Install and load the package `boot`.\n\n-   Make a histogram and a stem-and-leaf plot for the `thickness` variable of the `melanoma` data set.\n\n::: {.webex-check .webex-box}\nA. What is the shape of the distribution <select class='webex-select'><option value='blank'></option><option value=''>symmetric</option><option value='answer'>right-skewed</option><option value=''>left-skewe</option></select>\n\n\n\n\nB. Using the stem-and-leaf plot, which of the following intervals contains the median of the `thickness` variable? <div class='webex-radiogroup' id='radio_UWRVXUMLSL'><label><input type=\"radio\" autocomplete=\"off\" name=\"radio_UWRVXUMLSL\" value=\"\"></input> <span>0.5 – 1.0</span></label><label><input type=\"radio\" autocomplete=\"off\" name=\"radio_UWRVXUMLSL\" value=\"\"></input> <span>1.0 – 1.5</span></label><label><input type=\"radio\" autocomplete=\"off\" name=\"radio_UWRVXUMLSL\" value=\"answer\"></input> <span>1.5 – 2.0</span></label><label><input type=\"radio\" autocomplete=\"off\" name=\"radio_UWRVXUMLSL\" value=\"\"></input> <span>2.0 – 2.5</span></label><label><input type=\"radio\" autocomplete=\"off\" name=\"radio_UWRVXUMLSL\" value=\"\"></input> <span>2.5 – 3.0</span></label></div>\n\n\n\n:::\n:::\n\n\n\n\n## References\n\n-   Chen, Y. (2017). Lecture 7: Density Estimation. University of Washington. Retrieved October 05, 2024, from https://faculty.washington.edu/yenchic/17Sp_403/Lec7-density.pdf\n\n-   Daniel, W. W. and Cross, C. L. (2013). Biostatistics: A Foundation for Analysis in the Health Sciences, Tenth edition. Wiley\n\n-   Heumann, C., Schomaker, M., and Shalabh (2022). Introduction to Statistics and Data Analysis: With Exercises, Solutions and Applications in R. Springer\n\n-   Lane, D. M. et al., (2019). Introduction to Statistics. Online Edition. Retrieved September 14, 2024, from https://openstax.org/details/introduction-statistics\n\n<br>\n\n## Add your comments\n",
    "supporting": [
      "B002_Freq_dist2_ss_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<link href=\"../../site_libs/htmltools-fill-0.5.8.1/fill.css\" rel=\"stylesheet\" />\n<script src=\"../../site_libs/htmlwidgets-1.6.4/htmlwidgets.js\"></script>\n<link href=\"../../site_libs/datatables-css-0.0.0/datatables-crosstalk.css\" rel=\"stylesheet\" />\n<script src=\"../../site_libs/datatables-binding-0.33/datatables.js\"></script>\n<script src=\"../../site_libs/jquery-3.6.0/jquery-3.6.0.min.js\"></script>\n<link href=\"../../site_libs/dt-core-1.13.6/css/jquery.dataTables.min.css\" rel=\"stylesheet\" />\n<link href=\"../../site_libs/dt-core-1.13.6/css/jquery.dataTables.extra.css\" rel=\"stylesheet\" />\n<script src=\"../../site_libs/dt-core-1.13.6/js/jquery.dataTables.min.js\"></script>\n<link href=\"../../site_libs/crosstalk-1.2.1/css/crosstalk.min.css\" rel=\"stylesheet\" />\n<script src=\"../../site_libs/crosstalk-1.2.1/js/crosstalk.min.js\"></script>\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}