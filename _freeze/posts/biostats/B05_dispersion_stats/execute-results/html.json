{
  "hash": "ea31b86e523dcb5b94e946ad6cda31d2",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Measures of Variability\"\nimage: \"/images/biostats.jpg\"\ndate: \"2024-10-15\"\nformat: \n  html: \n    fig-align: center\n    page-layout: article\n    toc: true\n    toc-depth: 5\n    toc-expand: true\n    lightbox: false\ncrossref: \n  custom: \n    - kind: float\n      reference-prefix: \"Example M.10.\"\n      key: tabset\n      space-before-numbering: false\neditor_options: \n  chunk_output_type: console\n---\n\n::: {.cell}\n\n:::\n\n\n\n\n## Background\n\n-   Variability describes how the observations are dispersed around the center of the data.\n\n-   The terms `variability` and `dispersion` are used interchangeably.\n\n-   Two distributions can have the same mean but different variability (as depicted in the figure below).\n\n\n\n\n    ::: {.cell}\n    ::: {.cell-output-display}\n    ![](B05_dispersion_stats_files/figure-html/unnamed-chunk-2-1.png){width=672}\n    :::\n    :::\n\n\n\n\n    -   Despite having the same mean represented by the red vertical line, the blue distribution has a higher variability than the green distribution (i.e., the observations are more dispersed around the mean).\n    \n-   Therefore, it is important to report a measure of variability along with the measure of central tendency to provide a complete description of the data.\n\n## Measures variability\n\n-   In the following sections, we will discuss the most commonly used measures of variability.\n\n  \n### Range\n\n-   The range $(R)$ is defined as the difference between the maximum and minimum value of the data.\n\n$$\nR = x_{\\text{max}} - x_{\\text{min}}\n$$\n\n-   The range considers only two observations, so its use is limited.\n\n-   It is sensitive to extreme values.\n\n-   Because infinite number of distributions can have different maximum and minimum values but the same range, it can be helpful to report the range as the $[x_{\\text{min}},\\ x_{\\text{max}}]$. This approach conveys more information about the data. \n\n-   Example: the range of the variable `mpg` in the `mtcars` dataset is calculated in R using the `range()` function:\n\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    range(mtcars$mpg)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] 10.4 33.9\n    ```\n    \n    \n    :::\n    :::\n\n\n\n    \n    -   The output is a vector of two values representing the minimum and maximum values.\n\n### Median {#median}\n\n-   The median, denoted by $\\large \\tilde{x}_{0.5}$, is the value which divides the ordered observations into two equal parts (i.e., at least 50% of the values $\\ge$ the median and at least 50% of the values $\\le$ the median).\n\n\n-   The median is calculated as follows:\n\n    -   If the number of observations is odd, the median is the middle value of the ordered observations.\n\n    -   If the number of observations is even, the median is the arithmetic mean of the two middle observations.\n\n$$\n\\tilde{x}_{0.5} = \\begin{cases} x_{\\frac{n+1}{2}} & \\text{if $n$ is odd} \\\\ \\\\ \\frac{1}{2}(x_{\\frac{n}{2}} + x_{\\frac{n}{2}+1}) & \\text{if $n$ is even} \\end{cases}\n$$\n\n::: panel-tabset\n## Example B.3.1 {{< iconify ic:round-menu-book size=21px >}}\n\n-   Consider the following set of observations: $(3, 5, 7, 7, 7, 9, 11)$.\n\n    -   There is an odd number of observations $(7)$, so the median is the middle value of the ordered observations, which is ranked $\\displaystyle \\frac{n+1}{2} = \\frac{7+1}{2}=4^{th}$ and its value is $7$. \n    \n    -   Half of the measurements $(3, 5, 7)$ are below or equal to $7$, and half of the measurements $(7, 9, 11)$ are equal to or above $7$. \n    \n    -   Therefore, the previous defintion of the [median] contains \"equal to\" to cover the case of having repeated, similar values. \n\n## Example B.3.2 {{< iconify ic:round-menu-book size=21px >}}\n-   Example: the variable `mpg` has $32$ observations, so the median is the arithmetic mean of the two middle observations (i.e., the mean of the ordered observations ranked $\\displaystyle \\frac{32}{2} = 16$ and $\\displaystyle \\frac{32}{2} + 1 =17$):\n\n    -   The ordered observations are:\n\n\n\n\n        ::: {.cell}\n        \n        ```{.r .cell-code}\n        mpg_ordered <- sort(mtcars$mpg)\n        mpg_ordered\n        ```\n        \n        ::: {.cell-output .cell-output-stdout}\n        \n        ```\n         [1] 10.4 10.4 13.3 14.3 14.7 15.0 15.2 15.2 15.5 15.8 16.4 17.3 17.8 18.1 18.7\n        [16] 19.2 19.2 19.7 21.0 21.0 21.4 21.4 21.5 22.8 22.8 24.4 26.0 27.3 30.4 30.4\n        [31] 32.4 33.9\n        ```\n        \n        \n        :::\n        :::\n\n\n\n\n    -   The $16^{th}$ and $17^{th}$ ordered observations are:\n\n\n\n\n        ::: {.cell}\n        \n        ```{.r .cell-code}\n        mpg_ordered[16:17]\n        ```\n        \n        ::: {.cell-output .cell-output-stdout}\n        \n        ```\n        [1] 19.2 19.2\n        ```\n        \n        \n        :::\n        :::\n\n\n\n\n    -   The median is the arithmetic mean of these two values:\n\n\n\n\n        ::: {.cell}\n        \n        ```{.r .cell-code}\n        mean(mpg_ordered[16:17])\n        ```\n        \n        ::: {.cell-output .cell-output-stdout}\n        \n        ```\n        [1] 19.2\n        ```\n        \n        \n        :::\n        :::\n\n\n\n\n    -   The median can also be calculated using the built-in R function `median()`:\n\n\n\n\n        ::: {.cell}\n        \n        ```{.r .cell-code}\n        median(mtcars$mpg)\n        ```\n        \n        ::: {.cell-output .cell-output-stdout}\n        \n        ```\n        [1] 19.2\n        ```\n        \n        \n        :::\n        :::\n\n\n\n:::\n\n\n#### Characteristics of the median\n\n-   Unlike the mean, the median is not drastically affected by extreme values (outliers).\n\n-   Consider the example discussed above @lst-outlier:\n\n    -   The median of the original set of observations is:\n\n\n\n\n        ::: {.cell}\n        \n        ```{.r .cell-code}\n        median(c(32.1, 34.5, 33.6, 37.2, 39.4))\n        ```\n        \n        ::: {.cell-output .cell-output-stdout}\n        \n        ```\n        [1] 34.5\n        ```\n        \n        \n        :::\n        :::\n\n\n\n\n    -   The median of the set of observations with the outlier is:\n\n\n\n\n        ::: {.cell}\n        \n        ```{.r .cell-code}\n        median(c(32.1, 34.5, 33.6, 37.2, 250.1))\n        ```\n        \n        ::: {.cell-output .cell-output-stdout}\n        \n        ```\n        [1] 34.5\n        ```\n        \n        \n        :::\n        :::\n\n\n\n\n    -   Becuase the median is concerned with the middle value, it is less affected by the presence of the outliers than the mean.\n\n### Mode\n\n-   The mode of a set of observations is the observation that occurs most frequently compared with all other values,\n\n-   A set of observations can have:\n\n    -   No mode (if all observations occur with the same frequency).\n\n    -   One mode (if one observation occurs most frequently).\n\n    -   More than one mode (if two or more observations occur with the same highest frequency).\n\n-   Example: consider the variable `cyl` (number of car cylinders) in the `mtcars` dataset:\n\n    -   R has no direct built-in function to calculate the mode, but it can be calculated from the frequency table as follows:\n\n\n\n\n        ::: {.cell}\n        \n        ```{.r .cell-code}\n        library(dplyr)\n        # create table of the frequencies of the values\n        freq_tbl <- table(mtcars$cyl)\n        \n        # convert to adata frame\n        freq_df <- as.data.frame(freq_tbl)\n        \n        # arrange the values in descending order of frequency\n        freq_df <- \n          freq_df %>% \n            arrange(desc(Freq))\n            \n        freq_df\n        ```\n        \n        ::: {.cell-output .cell-output-stdout}\n        \n        ```\n          Var1 Freq\n        1    8   14\n        2    4   11\n        3    6    7\n        ```\n        \n        \n        :::\n        \n        ```{.r .cell-code}\n        paste(\n          \"The mode is\", \n          freq_df$Var1[which.max(freq_df$Freq)], \n          \"cyliners\"\n        )\n        ```\n        \n        ::: {.cell-output .cell-output-stdout}\n        \n        ```\n        [1] \"The mode is 8 cyliners\"\n        ```\n        \n        \n        :::\n        :::\n\n\n\n\n    -   The mode can also be calculated directly using the `Mode()` function from the `DescTools` package:\n\n\n\n\n        ::: {.cell}\n        \n        ```{.r .cell-code}\n        library(DescTools)\n        Mode(mtcars$cyl)\n        ```\n        \n        ::: {.cell-output .cell-output-stdout}\n        \n        ```\n        [1] 8\n        attr(,\"freq\")\n        [1] 14\n        ```\n        \n        \n        :::\n        :::\n\n\n\n\n        -   The first line of the output shows the mode ($8$ cylinders) and the last line shows the frequency of the mode.\n\n    ::: callout-caution\n    -   R has a built-in function `mode()` that returns the storage mode of an object (e.g., numeric, character, etc.) rather than the mode.\n\n\n\n\n        ::: {.cell}\n        \n        ```{.r .cell-code}\n        mode(mtcars$cyl)\n        ```\n        \n        ::: {.cell-output .cell-output-stdout}\n        \n        ```\n        [1] \"numeric\"\n        ```\n        \n        \n        :::\n        :::\n\n\n\n    :::\n\n    -   For numerical data which contains many unique values, the mode may not be a good measure of central tendency. However, if the observations are summarized in groups (e.g., frequency table or histogram), the mode can be calculated as the class interval with the highest frequency.\n\n        -   Example: consider the histogram of the variable `mpg` in the `mtcars` dataset:\n\n\n\n\n            ::: {.cell}\n            ::: {.cell-output-display}\n            ![](B05_dispersion_stats_files/figure-html/unnamed-chunk-13-1.png){width=672}\n            :::\n            :::\n\n\n\n\n            -   The class interval $(15, 20]$ has the highest frequency of $12$ observations, so the mode is the interval $(15, 20]$ (others may also consider the midpoint of the interval, $17.5$, as the mode).\n\n### Geometric mean\n\n-   Let $X$ a quantitative random variable with `positive` and `non-zero` values $x_1, x_2, \\ldots, x_n$, then the geometric mean $(\\bar{x}_G)$ is computed by multiplying all the values and then taking the $n^{th}$ root of the product:\n\n    $$\n    \\bar{x}_G = \\large \\sqrt[n]{x_1 \\times x_2 \\times \\ldots \\times x_n} = \\left( \\displaystyle \\prod_{i=1}^{n} x_i \\right)^{\\frac{1}{n}} \n    $$\n\n-   It is less sensitive to extreme values in skewed distributions than the arithmetic mean.\n\n-   Geometric mean is used for averaging data that are `multiplicative` in nature (e.g., percentage change and rates).\n\n    -   Percentage change is calculated as the difference between the final $(x_1)$ and initial $(x_0)$ values divided by the initial value, then multiplied by $100$:\n\n        $$\n            \\displaystyle \\text{Percentage change} = \\left( \\frac{x_1 - x_0}{x_0} \\right) \\times 100\n        $$\n\n        -   If the sign of the percentage change is positive, it indicates an increase, while a negative sign indicates a decrease.\n\n    -   Rate is the ratio of two quantities that describes how one quantity changes with respect to another (e.g., speed, growth rate, and interest rate).\n\n::: panel-tabset\n## Example B.3.3 {{< iconify ic:round-menu-book size=21px >}}\n\n-   Consider the following set of observations: $(4, 16, 64, 256)$.\n\n-   The geometric mean is calculated as:\n\n    $$\n      \\sqrt[4]{4 \\times 16 \\times 64 \\times 256} = \\sqrt[4]{1048576} = 32\n    $$\n\n-   The geometric mean can be calculated using the `Gmean()` function from the `DescTools` package or the `geometric.mean()` function from the `psych` package:\n\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    library(DescTools)\n    library(psych)\n    x <- c(4, 16, 64, 256)\n    Gmean(x)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] 32\n    ```\n    \n    \n    :::\n    \n    ```{.r .cell-code}\n    geometric.mean(x)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] 32\n    ```\n    \n    \n    :::\n    :::\n\n\n\n\n## Example B.3.4 {{< iconify ic:round-menu-book size=21px >}}\n\n-   Assume a bank provides the following interest rates for three years plan: $3.3\\%$ in the first year, $4.5\\%$ in the second year, and $5.2\\%$ in the third year. If a client deposits $\\textdollar{500}$, the change in the amount can be calculated as follows:\n\n    | Time | Year | Amount $(\\textdollar)$ | Rate $(\\%)$ | Interest $(\\textdollar)$ $(\\text{Rate}_t \\times \\text{Amount}_{t-1})$ | Growth factor $(\\text{Amount}_t/\\text{Amount}_{t-1})$ |\n    |:----------:|:----------:|:----------:|:----------:|:----------:|:----------:|\n    | $t_0$ | 0 | $500.0$ | – | – | – |\n    | $t_1$ | 1 | $516.5$ | $3.3$ | $16.5$ | $1.033$ |\n    | $t_2$ | 2 | $539.7$ | $4.5$ | $23.2$ | $1.045$ |\n    | $t_3$ | 3 | $567.8$ | $5.2$ | $28.1$ | $1.052$ |\n\n-   The interest rate is also known as the `growth rate`.\n\n-   The growth rate $= (\\text{growth factor} - 1) \\times 100$.\n\n-   The average growth factor is calculated as the geometric mean of the growth factors:\n\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    growth_factors <- c(1.033, 1.045, 1.052)\n    Gmean(growth_factors)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] 1.043304\n    ```\n    \n    \n    :::\n    :::\n\n\n\n\n-   So, the average growth rate per year $= (1.043 - 1) \\times 100 = 4.3\\%$.\n\n-   This average growth rate can also be obtained by calculating the geometric mean of the interest (growth) rates:\n\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    interest_rates <- c(3.3, 4.5, 5.2)\n    Gmean(interest_rates)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] 4.258369\n    ```\n    \n    \n    :::\n    :::\n\n\n\n\n-   However, this approach is not recommended because the interest rates can be negative (the rate decreases), which results in error while computing the geometric mean.\n\n-   The total amount of money ($A$) can be calculated at any year using the formula: $A_t = A_{t_0} \\times (\\text{average growth factor}) \\large ^t$. For example, the amount at the end of the third year $= 500 \\times 1.043304^3 = \\textdollar567.8$.\n\n## [Exercise B.3.1 {{< iconify fluent:chat-bubbles-question-20-filled size=21px >}}]{style=\"color: #ba181b\"}\n\n-   Calculate the average interest rate for the following four-year plan: $10\\%$, $14\\%$, $15\\%$, and $-5\\%$.\n\n    The average rate per year is <input class='webex-solveme nospaces' size='3' data-answer='[\"8.2\"]'/> $\\%$ (to one decimal place)\n\n\n<div class='webex-solution'><button>Click to show/hide answer</button>\n\n\n-   The average interest rate can not be computed directly by calculating the geometric mean of the interest rates because the last rate is negative.\n\n-   Therefore, we calculate the average growth factor as the geometric mean of the growth factors.\n\n-   Growth factor $= \\displaystyle \\frac{\\text{rate}}{100} + 1$\n\n-   So, the growth factors are $(1.1, 1.14, 1.15, 0.95)$.\n\n-   The average growth factor is equal to:\n\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    growth_factors <- c(1.1, 1.14, 1.15, 0.95)\n    Gmean(growth_factors)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] 1.081882\n    ```\n    \n    \n    :::\n    :::\n\n\n\n\n-   Therefore, the average interest rate per year is $8.2\\%$.\n\n\n</div>\n\n:::\n\n#### Geometric mean and logarihmic transformation\n\n-   If the observations are transformed by taking the logarithm (common or natural), [the antilogarithm of the arithmetic mean of the transformed values]{style=\"color: #0466c8\"} is equal to [the geometric mean of the original values]{style=\"color: #ba181b\"}.\n\n    -   Let $X$ be a random variable with positive, non-zero values $x_1, x_2, \\ldots, x_n$, and $Y$ is the transformed variable with values $y_1, y_2, \\ldots, y_n$ such that $y_i = \\log_{10}(x_i)$:\n\n    -   The arithmetic mean of the transformed values is calculated as:\n\n    $$\n     \\bar{y} = \\displaystyle \\frac{y_1 + y_2 + \\ldots + y_n}{n} = \\displaystyle \\frac{\\log_{10}(x_1) + \\log_{10}(x_2) + \\ldots + \\log_{10}(x_n)}{n} = \n    $$\n\n    $$\n    \\log_{10} \\left( \\sqrt[n]{x_1 \\times x_2 \\times \\ldots \\times x_n} \\right)\n    $$\n\n    -   The antilogarithm of the arithmetic mean of the transformed values is:\n\n    $$\n     10^{\\bar{y}} = 10^{\\log_{10} \\left( \\sqrt[n]{x_1 \\times x_2 \\times \\ldots \\times x_n} \\right)} = \\sqrt[n]{x_1 \\times x_2 \\times \\ldots \\times x_n}\n    $$\n\n    -   The last equation represents the geometric mean of the original values.\n\n-   Example: consider the following set of observations $(5,\\ 9,\\ 10,\\ 22,\\ 13, 50)$, the following table shows the original and log transformed values:\n\n    :::::: grid\n    ::: g-col-2\n    :::\n\n    ::: g-col-8\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    library(DT)\n    x <- c(5, 9, 10, 22, 13, 50)\n    y <- round(log10(x), 5)\n    \n    my_data <- data.frame(\n      Original = x,\n      Log_transformed = y\n    )\n    \n    datatable(\n      my_data, \n      options = list(\n        dom = \"t\",\n        columnDefs = list(\n          list(\n          className = \"dt-center\",\n          targets = \"_all\"\n          )\n        )\n      ),\n      rownames = FALSE\n    )\n    ```\n    \n    ::: {.cell-output-display}\n    \n    ```{=html}\n    <div class=\"datatables html-widget html-fill-item\" id=\"htmlwidget-f133f9a4461e7c1eb1b1\" style=\"width:100%;height:auto;\"></div>\n    <script type=\"application/json\" data-for=\"htmlwidget-f133f9a4461e7c1eb1b1\">{\"x\":{\"filter\":\"none\",\"vertical\":false,\"data\":[[5,9,10,22,13,50],[0.69897,0.95424,1,1.34242,1.11394,1.69897]],\"container\":\"<table class=\\\"display\\\">\\n  <thead>\\n    <tr>\\n      <th>Original<\\/th>\\n      <th>Log_transformed<\\/th>\\n    <\\/tr>\\n  <\\/thead>\\n<\\/table>\",\"options\":{\"dom\":\"t\",\"columnDefs\":[{\"className\":\"dt-center\",\"targets\":\"_all\"},{\"name\":\"Original\",\"targets\":0},{\"name\":\"Log_transformed\",\"targets\":1}],\"order\":[],\"autoWidth\":false,\"orderClasses\":false}},\"evals\":[],\"jsHooks\":[]}</script>\n    ```\n    \n    :::\n    :::\n\n\n\n    :::\n\n    ::: g-col-2\n    :::\n    ::::::\n\n    <br>\n\n    -   The arithmetic mean of the transformed values is:\n\n\n\n\n        ::: {.cell}\n        \n        ```{.r .cell-code}\n        mean(y)\n        ```\n        \n        ::: {.cell-output .cell-output-stdout}\n        \n        ```\n        [1] 1.134757\n        ```\n        \n        \n        :::\n        :::\n\n\n\n\n    -   The antilogarithm of the arithmetic mean of the transformed values is:\n\n\n\n\n        ::: {.cell}\n        \n        ```{.r .cell-code}\n        10^mean(y)\n        ```\n        \n        ::: {.cell-output .cell-output-stdout}\n        \n        ```\n        [1] 13.63819\n        ```\n        \n        \n        :::\n        :::\n\n\n\n\n    -   The geometric mean of the original values is:\n\n\n\n\n        ::: {.cell}\n        \n        ```{.r .cell-code}\n        Gmean(x)\n        ```\n        \n        ::: {.cell-output .cell-output-stdout}\n        \n        ```\n        [1] 13.63823\n        ```\n        \n        \n        :::\n        :::\n\n\n\n\n    -   The antilogarithm of the arithmetic mean of the transformed values is equal to the geometric mean of the original values.\n\n    ::: {.callout-note style=\"color: #0466c8;\"}\n    -   When the original values are log transformed, the back-transformed mean is not the same as the original mean but it is the geometric mean of the original values.\n\n    -   On the other hand, back-transforming the median of the log-transformed values gives the median of the original values:\n\n        -   For the `mpg` variable from the `mtcars` dataset, the median of the log-transformed values is:\n\n\n\n\n            ::: {.cell}\n            \n            ```{.r .cell-code}\n            med_log <- median(\n              log(mtcars$mpg))\n            med_log\n            ```\n            \n            ::: {.cell-output .cell-output-stdout}\n            \n            ```\n            [1] 2.95491\n            ```\n            \n            \n            :::\n            :::\n\n\n\n\n        -   The antilogarithm of the median (back transformation) of the log-transformed values is:\n\n\n\n\n            ::: {.cell}\n            \n            ```{.r .cell-code}\n            exp(med_log) # exponentiation to back transform\n            ```\n            \n            ::: {.cell-output .cell-output-stdout}\n            \n            ```\n            [1] 19.2\n            ```\n            \n            \n            :::\n            :::\n\n\n\n\n        -   The median of the original values is:\n\n\n\n\n            ::: {.cell}\n            \n            ```{.r .cell-code}\n            median(mtcars$mpg)\n            ```\n            \n            ::: {.cell-output .cell-output-stdout}\n            \n            ```\n            [1] 19.2\n            ```\n            \n            \n            :::\n            :::\n\n\n\n\n        -   The antilogarithm of the median of the log-transformed values is equal to the median of the original values.\n    :::\n\n### Harmonic mean\n\n-   The harmonic mean $(\\bar{x}_H)$ is the reciprocal of the arithmetic mean of the reciprocals of the observations:\n\n    -   Let $X$ be a random variable with values $x_1, x_2, \\ldots, x_n$, then the reciprocals of the observations are $\\displaystyle \\frac{1}{x_1}, \\frac{1}{x_2}, \\ldots, \\frac{1}{x_n}$, and their arithmetic mean is calculated as:\n\n    $$\n    \\displaystyle \\frac{1}{n} \\left( \\displaystyle \\frac{1}{x_1} + \\displaystyle \\frac{1}{x_2} + \\ldots + \\displaystyle \\frac{1}{x_n} \\right) = \\displaystyle \\frac{\\displaystyle \\sum_{i=1}^{n} \\frac{1}{x_i}}{n}\n     $$\n\n    -   The harmonic mean is the reciprocal of the arithmetic mean of the reciprocals:\n\n    $$\n     \\bar{x}_H = \\displaystyle \\frac{n}{\\displaystyle \\sum_{i=1}^{n} \\frac{1}{x_i}}\n     $$\n\n-   It is used for averaging data that are `ratios` or `rates` (e.g., speed or financial ratios).\n\n-   If the observations do not contribute equally towards the calculation of the mean (i.e., the observations have different weights), the harmonic mean can be weighted:\n\n    -   Let $X$ be a random variable with values $x_1, x_2, \\ldots, x_n$ that have coressponding weights $w_1, w_2, \\ldots, w_n$, then the harmonic mean is calculated as:\n\n    $$\n    \\text{Weighted}\\ \\bar{x}_H = \\displaystyle \\frac{w_1 + w_2 + \\ldots + w_n}{\\displaystyle \\frac{w_1}{x_1} + \\frac{w_2}{x_2} + \\ldots + \\frac{w_n}{x_n}} = \\displaystyle \\frac{\\displaystyle  \\sum_{i=1}^{n} w_i}{\\displaystyle \\sum_{i=1}^{n} \\frac{w_i}{x_i}} = \\displaystyle \\frac{1}{\\displaystyle \\sum_{i=1}^{n} \\frac{w_i}{x_i}} \n    $$\n\n-   Example: consider the following set of observations $(2, 4, 6, 8)$:\n\n    -   The harmonic mean is calculated as:\n\n\n\n\n        ::: {.cell}\n        \n        ```{.r .cell-code}\n        x <- c(2, 4, 6, 8)\n        n <- length(x)\n        harmonic_mean <- n / sum(1 / x)\n        harmonic_mean\n        ```\n        \n        ::: {.cell-output .cell-output-stdout}\n        \n        ```\n        [1] 3.84\n        ```\n        \n        \n        :::\n        :::\n\n\n\n\n    -   The harmonic mean can also be calculated using the `Hmean()` function from the `DescTools` package or `harmonic.mean()` function from the `psych` package:\n\n\n\n\n        ::: {.cell}\n        \n        ```{.r .cell-code}\n        library(DescTools)\n        Hmean(x)\n        ```\n        \n        ::: {.cell-output .cell-output-stdout}\n        \n        ```\n        [1] 3.84\n        ```\n        \n        \n        :::\n        \n        ```{.r .cell-code}\n        library(psych)\n        harmonic.mean(x)\n        ```\n        \n        ::: {.cell-output .cell-output-stdout}\n        \n        ```\n        [1] 3.84\n        ```\n        \n        \n        :::\n        :::\n\n\n\n\n-   The harmonic mean is used to calculate some statistical measures such as F1 score used to assess the performance of logistic regression models. In addition, it is used during pairwise multiple comparisons.  \n\n:::: panel-tabset\n## Example B.3.5 {{< iconify ic:round-menu-book size=21px >}}\n\nA car travels $100\\ \\text{km}$  at a speed $60\\ \\text{km/h}$, $100\\  \\text{km}$ at $70\\ \\text{km/h}$, $100\\ \\text{km}$ at $90\\ \\text{km/h}$, and $100\\ \\text{km}$ at $100\\ \\text{km/h}$. Calculate the average speed of the car.\n\n-   The arithmetic mean of the speed $= \\displaystyle \\frac{60 + 70 + 90 +100}{4} = \\frac{320}{4} = 80$ km/h.\n\n-   However, this method ignores the time taken to travel each distance.\n\n-   The time taken to travel each distance is given in the following table:\n\n| Speed (km/h) | Distanc (km) | Time (h) \\[Distance/Speed\\] |\n|:------------:|:------------:|:---------------------------:|\n|     $60$     |    $100$     |         $1.666667$          |\n|     $70$     |    $100$     |         $1.428571$          |\n|     $90$     |    $100$     |         $1.111111$          |\n|    $100$     |    $100$     |             $1$             |\n\n-   The total distance traveled is $400$ km, and the total time taken is $5.21\\ \\text{h}$  So, the actual average speed $= \\displaystyle \\frac{400}{5.206349} \\approx 76.83\\ \\text{km/h}$.\n\n-   This average can be found using the harmonic mean of the speeds:\n\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    speeds <- c(60, 70, 90, 100)\n    Hmean(speeds)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] 76.82927\n    ```\n    \n    \n    :::\n    :::\n\n\n\n\n-   The average speed can also be calculated as the weighted arithmetic mean using weights based on the time taken to travel each distance:\n\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    times <- c(100/60, 100/70, 100/90, 100/100) # use times as weights\n    weighted.mean(speeds, w = times)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] 76.82927\n    ```\n    \n    \n    :::\n    :::\n\n\n\n\n::: {.callout-note style=\"color: #0466c8;\"}\n-   To find the average of rates with different numerators but the same denominator use the arithmetic mean or weighted harmonic mean (weights are based on numerators).\n\n-   To find the average of rates with same numerators but different denominators use the harmonic mean or weighted arithmetic mean (weights are based on denominators).\n\n-   To find the average of rates with different numerators and denominators use the weighted arithmetic mean (weights are based on denominators) or weighted harmonic mean (weights are based on numerators).\n:::\n\n## Example B.3.6 {{< iconify ic:round-menu-book size=21px >}}\n\nSuppose that you invested $\\textdollar{2550}$ in stock market. In the first year, you spent $\\textdollar{1000}$ to purchase $40$ shares of stock $A$. In the second year, you spent $\\textdollar{1550}$ to purchase $78$ shares of the same stock. Calculate the average price per share.\n\n-   The rate here is the price $(\\textdollar)$ per share.\n\n-   The total amount of the shares bought $= 40 + 78 = 118$ shares, so the actual average price per share $= \\displaystyle \\frac{2550}{118} \\approx \\textdollar{21.61}$.\n\n-   In the first year, the price per share $= \\displaystyle \\frac{1000}{40} = \\textdollar{25}$.\n\n-   In the second year, the price per share $= \\displaystyle \\frac{1550}{78} \\approx \\textdollar{19.87}$.\n\n| Year | Price per share $(\\textdollar/\\text{share})$ | Amount invested $(\\textdollar)$ | Number of shares |\n|:----------------:|:----------------:|:----------------:|:----------------:|\n| $1$ | $25.00$ | $1000$ | $40$ |\n| $2$ | $19.87$ | $1550$ | $78$ |\n\n-   The arithmetic mean of the price per share $= \\displaystyle \\frac{25 + 19.87}{2} = \\displaystyle \\frac{44.87}{2} = \\textdollar{22.44}$, which is higher than the actual average price per share.\n\n-   Because both the numerator (amount invested) and denominator (number of shares) are different, the weighted arithmetic or weighted harmonic mean should be used to calculate the average price per share:\n\n    -   The weighted arithmetic mean using denominator (number of shares) as weights:\n\n\n\n\n        ::: {.cell}\n        \n        ```{.r .cell-code}\n        weights_1 <- c(40/118, 78/118)\n        price_1 <- 1000/40\n        price_2 <- 1550/78\n        weighted.mean(c(price_1, price_2), w = weights_1)\n        ```\n        \n        ::: {.cell-output .cell-output-stdout}\n        \n        ```\n        [1] 21.61017\n        ```\n        \n        \n        :::\n        :::\n\n\n\n\n    -   The weighted harmonic mean using numerators (amount invested) as weights:\n\n\n\n\n        ::: {.cell}\n        \n        ```{.r .cell-code}\n        weights_2 <- c(1000/2550, 1550/2550)\n        h_mean <- 1/sum(weights_2 / c(price_1, price_2))\n        h_mean\n        ```\n        \n        ::: {.cell-output .cell-output-stdout}\n        \n        ```\n        [1] 21.61017\n        ```\n        \n        \n        :::\n        :::\n\n\n\n::::\n\n### Trimmed mean\n\n-   The observations are arranged based on magnitude, then a certain percentage of the observations are removed from both ends of the ordered observations.\n\n-   The trimmed mean $(\\bar{x}_T)$ is then calculated as the arithmetic mean of the remaining observations.\n\n-   Typically, $5\\%$ to $25\\%$ of the observations are trimmed from each end.\n\n-   The trimmed mean is less sensitive to outliers than the arithmetic mean becuase the extreme values are removed.\n\n-   Some robust statistical tests use the trimmed mean such as **Yuen's test**, which is used to compare the trimmed means of two groups when the assumption of normality is violated.\n\n-   Trimmed mean can be calculated in R using the `mean()` function with the `trim` argument set to the percentage of observations to be trimmed.\n\n    -   Example: the $5\\%$ trimmed mean of the variable `mpg` in the `mtcars` dataset is calculated as follows:\n\n\n\n\n        ::: {.cell}\n        \n        ```{.r .cell-code}\n        mean(mtcars$mpg, trim = 0.05)\n        ```\n        \n        ::: {.cell-output .cell-output-stdout}\n        \n        ```\n        [1] 19.95333\n        ```\n        \n        \n        :::\n        :::\n\n\n\n\n        -   `DescTools` package has a function `Trim()` that is an excerpt from the base function `mean()` but returns the trimmed data without calculating the mean:\n\n\n\n\n            ::: {.cell}\n            \n            ```{.r .cell-code}\n            library(DescTools)\n            mpg_ordered <- sort(mtcars$mpg)\n            Trim(mpg_ordered, 0.05)\n            ```\n            \n            ::: {.cell-output .cell-output-stdout}\n            \n            ```\n             [1] 10.4 13.3 14.3 14.7 15.0 15.2 15.2 15.5 15.8 16.4 17.3 17.8 18.1 18.7 19.2\n            [16] 19.2 19.7 21.0 21.0 21.4 21.4 21.5 22.8 22.8 24.4 26.0 27.3 30.4 30.4 32.4\n            attr(,\"trim\")\n            [1]  1 32\n            ```\n            \n            \n            :::\n            :::\n\n\n\n\n            -   The output shows the cleaned data after trimming $5\\%$ of the observations from each end and the location of the trimmed observations (the $1^{\\text{st}}$ and $32^{\\text{nd}}$ observations that were removed).\n\n            -   The percentage of trimming is multiplied by the number of observations to get the number of observations to be trimmed from each end (i.e., $0.05 \\times 32 = 1.6$ observations, which R rounds down to $1$).\n\n            -   Therefore, one observation has been removed from each end.\n            \n-   $50\\%$ trimming is equivalent to the median:\n\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    mean(mtcars$mpg, trim = 0.5)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] 19.2\n    ```\n    \n    \n    :::\n    :::\n\n\n\n\n-   Discarding the extreme values leads to loss of information that can introduce bias in the estimation of the mean. Therefore, trimming should be used cautiously. It can be safely used to discard extreme values (outliers) that might be due to errors during measurement or data collection or when the extreme values are irrelevant to the rest of the data.\n\n### Winsorized mean\n\n-   The observations are arranged based on magnitude, then the extreme values beyond a certain percentile threshold are replaced by these threshold values.\n\n-   For example, $5\\%$ Winsorization involves replacing the values smaller than the $5^{th}$ percentile with the $5^{th}$ percentile value and the values larger than the $95^{th}$ percentile with the $95^{th}$ percentile value.\n\n-   The Winsorized mean $(\\bar{x}_W)$ is then calculated as the arithmetic mean of the modified observations.\n\n-   The Winsorized mean is less sensitive to outliers than the arithmetic mean.\n\n-   To Winsorize data, the `Winsorize()` function from the `DescTools` package can be used:\n\n    -   The function has `probs` argument that takes a vector of two values representing the lower and upper percentiles to be Winsorized (e.g., `probs = c(0.05, 0.95)` for $5\\%$ Winsorization).\n\n    -   In addition, there is `type` argument that specifies the algorithm to be used for calculating the perecentiles (this will be discussed under later Percentiles).\n\n    -   Example: the variable `mpg` in the `mtcars` dataset is $5\\%$ Winsorized as follows:\n    \n    -   Calculate the $5^{th}$ and $95^{th}$ percentiles of the variable `mpg`:\n\n\n\n\n        ::: {.cell}\n        \n        ```{.r .cell-code}\n        quantile(\n          mtcars$mpg, \n          probs = c(0.05, 0.95),\n          type = 7\n        )\n        ```\n        \n        ::: {.cell-output .cell-output-stdout}\n        \n        ```\n            5%    95% \n        11.995 31.300 \n        ```\n        \n        \n        :::\n        :::\n\n\n\n        \n        -   The quantile() function has been used to calculate the $5^{th}$ and $95^{th}$ percentiles of the variable `mpg`, which are $11.995$ and $31.3$, respectively. The `type` argument is set to $7$, which is the default algorithm for calculating the percentiles in R for continuous data.\n        \n    -   Display the original values in order:\n\n\n\n\n        ::: {.cell}\n        \n        ```{.r .cell-code}\n        mpg_ordered\n        ```\n        \n        ::: {.cell-output .cell-output-stdout}\n        \n        ```\n         [1] 10.4 10.4 13.3 14.3 14.7 15.0 15.2 15.2 15.5 15.8 16.4 17.3 17.8 18.1 18.7\n        [16] 19.2 19.2 19.7 21.0 21.0 21.4 21.4 21.5 22.8 22.8 24.4 26.0 27.3 30.4 30.4\n        [31] 32.4 33.9\n        ```\n        \n        \n        :::\n        :::\n\n\n\n      \n    -   Winsorize the variable `mpg` using the $5^{th}$ and $95^{th}$ percentiles:\n\n\n\n        ::: {.cell}\n        \n        ```{.r .cell-code}\n        mpg_win <- Winsorize(\n            x = mpg_ordered, \n            probs = c(0.05, .95), \n            type = 7\n        )\n        mpg_win\n        ```\n        \n        ::: {.cell-output .cell-output-stdout}\n        \n        ```\n         [1] 11.995 11.995 13.300 14.300 14.700 15.000 15.200 15.200 15.500 15.800\n        [11] 16.400 17.300 17.800 18.100 18.700 19.200 19.200 19.700 21.000 21.000\n        [21] 21.400 21.400 21.500 22.800 22.800 24.400 26.000 27.300 30.400 30.400\n        [31] 31.300 31.300\n        ```\n        \n        \n        :::\n        :::\n\n\n\n\n        -   The output of the `Winsorize()` function shows that the two smallest values $(10.4\\ \\text{and}\\ 10.4)$ that are smaller than the $5^{th}$ percentile $(11.995)$ have been replaced by the $5^{th}$ percentile. Whereas, the two largest values $32.4\\ \\text{and}\\ 33.9$ that are larger than the $95^{th}$ percentile $(31.3)$ have been replaced by the $95^{th}$ percentile.\n        \n    -   Calculate the Winsorized mean of the variable `mpg`:\n\n\n\n\n        ::: {.cell}\n        \n        ```{.r .cell-code}\n        mean(mpg_win)\n        ```\n        \n        ::: {.cell-output .cell-output-stdout}\n        \n        ```\n        [1] 20.07469\n        ```\n        \n        \n        :::\n        :::\n\n\n\n        \n    -   The Winsorized mean can be calculated directly using the function `winsor.mean()` function from the `psych` package:\n\n\n\n\n        ::: {.cell}\n        \n        ```{.r .cell-code}\n        library(psych)\n        \n        winsor.mean(\n           mtcars$mpg, \n           trim = 0.05\n        )\n        ```\n        \n        ::: {.cell-output .cell-output-stdout}\n        \n        ```\n        [1] 20.07469\n        ```\n        \n        \n        :::\n        :::\n\n\n\n-   Unlike trimming, Winsorization preserves some of the original information in the data. The extreme values are not totally discarded but their weight (impact) is reduced. \n\n\n        \n\n## References\n\n-   Chen, Y. (2017). Lecture 7: Density Estimation. University of Washington. Retrieved October 05, 2024, from https://faculty.washington.edu/yenchic/17Sp_403/Lec7-density.pdf\n\n-   Daniel, W. W. and Cross, C. L. (2013). Biostatistics: A Foundation for Analysis in the Health Sciences, Tenth edition. Wiley\n\n-   Heumann, C., Schomaker, M., and Shalabh (2022). Introduction to Statistics and Data Analysis: With Exercises, Solutions and Applications in R. Springer\n\n-   Lane, D. M. et al., (2019). Introduction to Statistics. Online Edition. Retrieved September 14, 2024, from https://openstax.org/details/introduction-statistics\n\n<br>\n\n## Add your comments\n",
    "supporting": [
      "B05_dispersion_stats_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<link href=\"../../site_libs/htmltools-fill-0.5.8.1/fill.css\" rel=\"stylesheet\" />\n<script src=\"../../site_libs/htmlwidgets-1.6.4/htmlwidgets.js\"></script>\n<link href=\"../../site_libs/datatables-css-0.0.0/datatables-crosstalk.css\" rel=\"stylesheet\" />\n<script src=\"../../site_libs/datatables-binding-0.33/datatables.js\"></script>\n<script src=\"../../site_libs/jquery-3.6.0/jquery-3.6.0.min.js\"></script>\n<link href=\"../../site_libs/dt-core-1.13.6/css/jquery.dataTables.min.css\" rel=\"stylesheet\" />\n<link href=\"../../site_libs/dt-core-1.13.6/css/jquery.dataTables.extra.css\" rel=\"stylesheet\" />\n<script src=\"../../site_libs/dt-core-1.13.6/js/jquery.dataTables.min.js\"></script>\n<link href=\"../../site_libs/crosstalk-1.2.1/css/crosstalk.min.css\" rel=\"stylesheet\" />\n<script src=\"../../site_libs/crosstalk-1.2.1/js/crosstalk.min.js\"></script>\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}